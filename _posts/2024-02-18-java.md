---
title: "자바의 개념"
author:
  name: 김병우
  link: https://github.com/Woob29
date: 2024-02-18 15:09:00 +0900
categories: [자바, 개념정리]
---

# `자바의 특징과 장단점`

- 캡슐화,상속,다형성이 잘 적용된 객체 지향 언어이다.
- 플랫폼이 독립적이다.
- 가비지 컬렉션 기능이 있다.

#### **장점**
  1. 안정성과 보안성이 뛰어나다.
  2. 많은 라이브러리를 제공하여 다양한 개발에 용이하다.
  3. 가비지 컬렉션으로 메모리를 자동으로 관리한다.

#### **단점**
  1. JVM에서 동작하기 때문에 느리다.
  2. 메모리 사용량이 높다.

---

# `JVM 이란`

- Java Virtual Machine( JVM )은 자바 바이트 코드를 실행하는 가상머신으로 스레드 관리, 가비지 컬렉션으로 메모리관리 등을 수행 한다.
- 각 운영 체제에 맞는 네이티브 코드를 생성하여 실행

---

# `JDK와 JRE의 차이점`

- 둘 다 자바 프로그램을 개발 및 실행하는 데 필요한 도구와 라이브러리
- JDK는 JRE를 포함

#### **JDK**
  1.  자바 애플리케이션을 개발할 때 필요한 모든 도구를 제공하는 패키지

#### **JRE**
  1.  자바 애플리케이션을 실행할 때 필요한 환경을 제공하는 패키지
  2.  자바 애플리케이션을 실행하는 데 필요한 최소한의 요소만을 포함

---

# `자바의 원시타입 종류(기본자료형), 각각 차지하는 바이트`

#### **정수형**
  - byte(1), short(2), int(4), long(8)

#### **실수형**
  - float(4), double(8)

#### **문자형**
  - char(2)

#### **논리형**
  - boolean(1)

---

# `oop(객체 지향 프로그래밍)란`

- 객체가 중심인 누가 어떤 일을 할 것인가에 대한 소프트웨어 개발 및 설계방식 중 하나
- 클래스, 객체, 캡슐화, 상속, 다형성을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는데 기여한다.

---

# `자바에서 클래스와 객체란`

#### **클래스**
  1.  객체를 만들기 위한 틀 또는 설계도
  2.  필드(선언된 데이터) + 메소드(함수) + 생성자로 구성
  3.  클래스는 다른 클래스로부터 상속을 받을 수 있으며, 상속을 통해 코드의 재사용성을 높일 수 있다.

#### **객체**
  1.  클래스의 인스턴스 즉 구체적인 실체
  2.  객체는 메모리에 할당되어 사용
  3.  하나의 클래스로부터 여러 개의 객체를 생성가능

---

# `자바에서 상속이란(IS관계)`

- 한 클래스가 다른 클래스의 특성(필드와 메서드)을 물려 받는 것을 의미
- 자식 클래스는 부모 클래스에서 정의된 필드와 메서드를 직접적으로 사용할 수 있으며, 필요한 경우에는 자식 클래스에서 새로운 필드나 메서드를 추가할 수 있다.
- 코드의 재사용성, 확장성, 다형성이 좋아진다.

---

# `Has관계란`

- 클래스가 다른 클래스의 객체를 포함하고 있는 경우
- 객체 간의 결합도를 느슨하게 유지(약한 결합)
- 클래스 간의 의존성이 낮다.

---

# `자바에서 다형성이란`

- 객체 지향 프로그래밍 핵심 원리중 하나로 메소드의 오버로딩, 오버라이딩, 상속 등을 통해 코드의 유연성과 재사용성을 높일 수 있다.

---

# `참조 자료형 변환이란`

- 객체 지향 프로그래밍에서 한 타입의 참조 변수를 다른 타입의 참조 변수로 변환하는 것
- 상속이 있어야 할 수 있다.
- 업 캐스팅(upcasting)과 다운 캐스팅(downcasting) 두가지 유형이 있다.

#### **업 캐스팅**
  1.  객체는 자식인데 변수 자료형 부모인 경우, 즉 자식 클래스의 객체를 부모 클래스의 타입으로 참조하고 있는 상황을 의미
  2.  항상 안전하며, 명시적으로 형변환하지 않아도 된다.

#### **다운 캐스팅**
  1.  변수의 자료형이 부모였는데 다시 본인 자료형으로 바꾸는 경우
  2.  명시적으로 형변환을 해야하며, 실행 시간에 발생하는 유형 확인과 캐스트 예외가 발생가능
  3.  잘못된 형변환 시 ClassCastException이 발생가능

---

# `자바에서 캡슐화란`

- 객체지향 프로그래밍의 핵심 개념 중 하나
- 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶는 것으로 객체의 내부 상태를 보호 및 외부 접근 제어

---

# `접근 제한자란`

- 캡슐화를 구현하는 데 사용되는 도구 중 하나
- 클래스, 메서드, 필드 등의 멤버에 대한 접근 권한을 제어하는 데 사용
- public -> protected -> default -> parivate (큰 범위 ~ 작은 범위)

#### **public**
  - 공용, 누구나 사용 가능

#### **protected**
  - 상속받은 클래스만 사용 가능

#### **default**
  - 같은 패키지 내에서만 사용 가능

#### **private**
  - 해당 멤버를 선언한 클래스 내에서만 사용 가능(상속 관계에서도 접근 불가)

---

# `생성자란`

- 객체를 생성할 때 호출되는 특수한 종류의 메서드로 객체의 초기화를 위해 사용, 생성될때 자동 호출
- 명시적으로 정의하지 않으면 컴파일러가 기본 생성자를 자동으로 제공
- 상속되지 않음
- 오버로딩 가능

---

# `생성자와 매소드 같은점과 다른점`
- 매개변수 사용이 가능하다.
- 반복문이나 조건문을 사용해여 기능 구현이 가능하다.

#### **생성자**
  1. 생성자는 객체를 초기화하는 데 사용되며 반환 유형이 없다.
  2. 이름을 마음대로 정할 수 없다. 
  3. 객체를 생성할 때 한 번만 호출된다.
  
#### **매소드**
  1. 매서드는 객체의 동작을 정의한다.
  2. 이름을 정할 수 있다. 
  3. 반환 유형이 있다.

---

# `오버라이딩과 오버로딩이란`

#### **오버라이딩**
  - 상위 클래스(부모 클래스)의 메서드를 하위 클래스(자식 클래스)에서 같은 이름의 메서드로 재정의하는 것을 의미

#### **오버로딩**
  - 같은 이름의 메서드를 여러 개 정의하고, 매개변수의 개수나 타입을 다르게하여 다양한 형태의 호출을 지원하는 것을 의미

---

# `객체지향의 설계원칙`

#### **SRP ( 단일 책임 원칙 )**
  - 한 클래스는 하나의 책임만 가져야 한다.

#### **OCP ( 개방 - 폐쇄 원칙 )**
  - 확장에는 열려있고, 수정에는 닫혀있어야 한다.

#### **LSP ( 리스코프 치환 원칙 )**
  - 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.

#### **ISP ( 인터페이스 분리 원칙 )**
  - 인터페이스 내에 메소드는 최소한 일수록 좋다.

#### **DIP ( 의존관계 역전 원칙 )**
  - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.

---

# `자바 바이트 코드(java bytecode)란`

- 자바 가상 머신 (JVM)이 이해할 수 있는 중간 언어
- 자바 소스 코드를 컴파일 하여 생성된 코드
- 특정 플랫폼에 의존하지 않으며, 여러 플랫폼에서 동일하게 실행

---

# `가비지컬렉션(Garbage Collection)이란`

- 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 메모리(가비지(Garbage))를 자동으로 해제하는 메모리 관리 기법
- 메모리 누수 방지, 프로그램의 안정성을 높여준다.
- 단점으로는 개발자가 메모리가 언제 해제되는지 알 수 없다.
- 가비지컬렉션이 동작하는동안 다른 동작을 멈추기 때문에 오버헤드 발생가능

---

# `가비지컬렉션 과정`

- JVM 실행을 일시적으로 멈추고 가비지컬렉션( GC )을 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 사용하지 않는 메모리를 제거 후 작동 재개

---

# `자바에서 스레드란`

- 프로그램의 실행 흐름을 나타내는 가장 작은 단위
- 각각의 스레드는 독립적으로 실행되며, 멀티코어 프로세서를 활용하여 여러 스레드가 서로 다른 작업을 동시에(병렬) 수행가능
- 프로세스 내에서 실행되며, 하나의 프로세스에는 여러 개의 스레드가 있을 수 있다.

---

# `자바와 C++의 공통점과 차이점`

- 둘다 객체 지향 프로그래밍이다.
- 정적 타입 언어로서 변수의 데이터 타입이 컴파일 시 결정된다.

#### **자바**
  1. 가비지 컬렉터를 통한 메모리 자동관리
  2. 플랫폼이 독립적이다.
  3. 느린 실행속도

#### **c++**
  1. 개발자가 메모리 직접관리
  2. 플랫폼이 종속적이다.
  3. 빠른 실행속도

---

# `자바의 메모리 영역이란`

- 자바 프로그램이 실행될 때 사용되는 메모리 공간을 물리적인 영역으로 분할한 것

#### **힙(Heap) 영역**
  1. 객체와 배열이 동적으로 할당되는 영역
  2. 가비지 컬렉션의 대상이 되며, 가비지 컬렉터에 의해 관리
  3. 참조 변수에 의해 접근되며, 참조가 없어지면 가비지 컬렉터에 의해 메모리에서 해제
  4. 런타임시 할당

#### **스택(Stack) 영역**
  1. 메서드 호출과 지역 변수들이 저장되는 영역
  2. 메서드 호출 시마다 호출 스택 프레임이 생성되어 호출 정보와 지역 변수들을 저장
  3. 실행이 끝나면 해당 메서드의 호출 스택 프레임이 제거되어 메모리에서 해제
  4. 메소드가 호출될 때 할당

#### **메서드(Method Area 또는 PermGen) 영역**
  1. 클래스의 구조(메서드와 필드의 정보), 정적 변수, 상수, 메서드 코드 등을 저장하는 영역
  2. 주로 클래스 로더에 의해 로딩된 클래스들의 정보가 저장되며, 모든 스레드가 공유하는 영역
  3. JVM이 동작해서 클래스가 로딩될 때 생성

---

# `자바에서 동기화란`

- 여러 스레드가 공유된 자원 또는 데이터에 동시에 접근할 때 발생할 수 있는 문제를 해결하기 위한 메커니즘
- 여러 스레드 간의 데이터 일관성을 보장하기 위해 사용
- 한 번에 하나의 스레드만 실행되며, 다른 스레드들은 해당 블록이나 메서드가 실행 완료될 때까지 대기
- 스레드 간의 실행 순서를 제어하여 데이터의 일관성을 유지하고 경쟁 조건(Race Condition)을 방지가능
- 주요 동기화 매커니즘으로는 synchronized 키워드, ReentrantLock 클래스가 있다.

---

# `synchronized란`

- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념
- 동기화된 블록 또는 메서드 내에서는 한 번에 하나의 스레드만 실행되며, 다른 스레드는 해당 블록이나 메서드의 실행이 완료될 때까지 대기
- 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있다.

---

# `ReentrantLock 클래스란`

- synchronized키워드의 단점을 극복하기 위한 대안으로 도입, 세밀한 동기화 제어가 가능
- 진입 가능한( lock ) 잠금을 제공하며, 공정한 잠금 획득을 지원 및 조건 변수를 사용하여 스레드의 상태를 기다리고 조절가능
- 시간 제한을 두고 잠금을 시도를 통해 성능 향상 및 데드락 방지 가능

---

# `데드락이란`

- 두 개 이상의 스레드가 서로 상대방의 자원을 기다리며 무한히 대기하는 상태
- 예방을 위해 상호배제, 점유대기, 비선점, 순환대기 등의 조건을 만족시키지 않도록 주의

---

# `공정한 잠금(Fair Lock) 이란`

- 다중 스레드가 잠금을 획득하는 순서를 제어하는 방식
- 여러 스레드가 잠금을 획득하려고 시도할 때, 이를 기다리는 순서가 정해져 있어서 어떤 스레드도 계속해서 잠금을 획득하지 못하는 현상을 방지

---

# `클래스와 인터페이스의 차이점`

#### **클래스**
  1. 상태와 행동을 가지고 있는 객체를 만들기 위한 틀
  2. 필드, 메서드, 생성자 등을 포함하며 구현 가능
  3. 단일 상속만 가능

#### **인터페이스**
  1. 특정 기능을 정의하는데 사용
  2. 추상 메서드의 집합으로 구현이 불가능
  3. 인터페이스를 구현한 클래스는 해당 인터페이스의 메서드를 모두 구현해야한다.
  4. 다중상속 가능

---

# `추상화란`

- 객체의 공통된 특성을 추출하여 일반화시키는 과정
- 데이터나 프로세스의 복잡성을 숨기고 필요한 부분만을 강조하여 표현하는 것을 의미
- 추상화 방법으로는 추상 클래스, 인터페이스가 있다.
- 필수적으로 상속을 해야한다.

---

# `추상클래스와 인터페이스의 공통점과 차이`

- 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용
- 하위 클래스에서 확장/구현 해야 사용 가능
- 인스턴스 생성 불가능

#### **추상클래스**
  1. 일반 클래스와 비슷하지만, 추상 메서드를 포함할 수 있다.
  2. 단일 상속만 가능

#### **인터페이스**
  1. 추상 메서드만을 포함 가능, 모든 메서드가 추상 메서드이므로 일반 필드를 가질 수 없다.
  2. 다중 상속 가능
  3. 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제

---

# `try-catch-finally란`

- 예외 처리를 위한 구문

#### **try**
  - 예외가 발생할 수 있는 코드 입력

#### **catch**
  - 예외가 발생하면 해당 예외를 처리할 catch 블록으로 이동

#### **finally**
  - 예외 발생 여부와 상관없이 항상 실행
  - 주로 리소스 해제와 관련된 코드를 작성

---

# `try-with-resources란`

- try-catch-finally의 문제점을 보완하기 위해 나온 개념
- 자원을 사용한 후에 finally 블록이나 명시적으로 리소스를 해제하는 코드를 작성할 필요 없이, 자원을 자동으로 해제 가능
- AutoCloseable 인터페이스를 구현한 리소스를 사용할 때 자동으로 리소스를 해제

---

# `AutoCloseable란`

- try-with-resources 구문에서 사용되어 자원을 자동으로 닫을 수 있도록 하는 인터페이스
- 일반적으로 파일 입출력, 데이터베이스 연결, 네트워크 연결 등의 자원을 사용할 때 자주 활용

---

# `Error와 Exception의 차이`

#### **Error**
  1. 프로그램에서 복구할 수 없는 치명적인 오류
  2. 컴파일 시간에는 확인할 수 없고, 오류가 발생하면 프로그램이 비정상적으로 종료될 수 있다.
  3. Unchecked Exception에 해당

#### **Exception**
  1. 프로그램 실행 중에 발생하는 예외
  2. try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

---

# `CheckedException과 UnCheckedException의 차이`

- 예외를 처리하는 방법을 나타내는 데 사용
- RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스 이다.

#### **Checked Exception (검사 예외)**
  1. 컴파일 시점에 확인되는 예외( 실행하기 전에 예측 가능한 예외 )로, 반드시 예외를 처리 필요
  2. 대표적인 예로 IOException, SQLException 등

#### **UnCheckedException(비검사 예외 또는 런타임 예외)**
  1. 컴파일 시점에 확인되지 않는 예외( 실행하고 난 후에 알 수 있는 예외 )로, 예외 처리를 선택적으로 할 수 있다.
  2. 대표적인 예로 NullPointerException, IllegalArgumentException 등

---

# `String, StringBuffer, StringBuilder의 차이`

#### **String**
  1. 문자열을 변경할 수 없는 불변(immutable) 클래스
  2. 한 번 생성된 문자열은 변경할 수 없으며, 변경 시 새로운 문자열이 생성
  3. 멀티 스레드 환경에서 안전

#### **StringBuffer**
  1. 가변(mutable)한 문자열을 처리하기 위한 클래스
  2. 문자열을 동적으로 변경가능
  3. 동기화되어 있어 멀티스레드 환경에서 안전하게 사용가능

#### **StringBuilder**
  1. 가변(mutable)한 문자열을 처리하기 위한 클래스
  2. 동기화되지 않아 싱글스레드에서 사용
  3. 동기화에 대한 오버헤드가 없음

---

# `String 객체가 불변인 이유`

#### **보안성**
  - 문자열이 한 번 생성되면 그 값을 변경할 수 없으므로 중요한 정보가 변경되는 것을 방지

#### **스레드 안전성**
  - 불변한 문자열은 한 번 생성된 후에 변경되지 않으므로 여러 스레드가 동시에 문자열을 읽어도 안전

#### **캐싱**
  - 동일한 문자열 리터럴은 동일한 문자열 객체를 참조하므로 중복된 문자열 리터럴이 메모리에 여러 번 생성되지 않아 메모리 사용을 최적화하고 성능을 향상

---

# `불변객체란 무엇이고 사용해야하는 이유는`

- 불변객체란 한 번 생성되면 내부 상태가 변경될 수 없는 객체
- 주로 함수형 프로그래밍과 멀티스레드 환경에서 사용
- 프로그램의 안전성과 유지 보수성을 높이는 데 도움
- String 클래스와 Integer 클래스, final 키워드를 사용해 불변 객체를 만들 수 있다
- 특징으로는 내부 상태 변경 불가능, 스레드 안전성, 캐싱, 객체 공유 가능

---

# `final / finally / finalize 의 차이`

#### **final**
  1. 클래스, 메소드, 변수, 인자를 선언할 때 사용
  2. 클래스의 경우 final 키워드를 사용하여 해당 클래스를 상속할 수 없게 할 수 있다.
  3. 한 번 초기화되면 다시 할당할 수 없다.

#### **finally**
  1. 예외 처리(try-catch) 블록에서 사용되며, 항상 실행되어야 하는 코드를 정의
  2. 주로 리소스 해제나 정리 코드를 finally 블록에 포함하여 안전하게 처리

#### **finalize**
  1. 객체 소멸 직전에 호출되는 메서드
  2. 객체가 가비지 컬렉션될 때 호출되며, 해당 객체가 사용한 리소스를 해제하거나 정리하는 등의 마무리 작업을 수행 가능
  3. 객체의 소멸 직전에 호출되는 메서드이지만 호출 시점은 보장되지 않기 때문에 자원을 해제하는 용도로 사용하기보다는 GC의 동작을 보조하는 용도로 사용

---

# `new String()과 리터럴("")의 차이`

- new String()으로 생성된 문자열은 메모리 사용이 증가 할 수 있기 떄문에 일반적으로 문자열 리터럴을 사용하는 것이 메모리 및 성능 면에서 더 효율적이다.

#### **new String()**
  - new 키워드로 매번 새로운 객체를 생성
  - Heap 메모리 영역에 저장

#### **리터럴("")**
  - 자바의 String Pool에 저장되어 재사용

---

# `재귀함수란`

- 함수가 자신을 호출하는 것을 허용하는 함수
- 반복적인 작업을 해결하는 데 사용
- 무한 루프에 빠지지 않도록 종료 조건을 잘 설정해야 하며, 재귀 호출의 깊이가 너무 깊어지지 않도록 주의해야 한다.

```java
// 0 ~ a 까지의 합 계산
public int abc( int a ){
    if( a == 0 ){
        return 0;
    }
    else{
        return abc( a - 1 ) + a;
    }
}
```

---

# `Math.round()란`

- float 또는 double 타입(실수)의 값을 매개변수로 받아서 가장 가까운 정수로 반올림한 값을 반환

```java
double number1 = 3.6;
double number2 = 3.2;
int roundedNumber1 = Math.round(number1); // 출력시 4
int roundedNumber2 = Math.round(number2); // 출력시 3
```

---

# `자바에서 람다식이란`

- 함수형 프로그래밍 기법으로, 익명 함수를 생성하기 위한 간결한 문법을 제공
- 코드의 간결성과 가독성을 높아진다.
- ( 매개 변수 목록 ) -> { 실행 문 }

```java
public int sum(int a, int b) {
    return a + b;
}
// 위 코드를 람다식을 변경하면
(a, b) -> a + b;
```

---

# `자바에서 Stream API란`

- 컬렉션을 함수형 프로그래밍의 데이터 처리를 간결하고 효율적으로 처리하는 기능을 제공
- 스트림은 데이터의 흐름을 추상화한 것으로, 여러 종류의 데이터 소스(컬렉션, 배열, 파일 등)로부터 데이터를 읽고 쓰는데 사용
- 데이터를 처리하는 작업을 병렬로 처리하거나 간결하게 표현 가능

```java
// 짝수 필터링 후 합계 계산 예제
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

int sumNumbers = numbers.stream()        // 리스트로부터 스트림 생성
        .filter(n -> n % 2 == 0)         // 짝수만 필터링
        .mapToInt(n -> n)                // Integer를 int로 변환
        .sum();                          // 합계 계산

System.out.println("Sum Numbers : " + sumNumbers);
```

---

# `Stream API와 빌더 패턴의 차이`

- Stream API는 데이터 처리에 사용되고, 빌더 패턴은 객체 생성에 사용

#### **Stream API**
  1. 데이터를 처리하고 변환하는 데 사용
  2. 주로 컬렉션, 배열 또는 파일과 같은 데이터 소스에서 데이터를 읽고 처리하는 데 사용

#### **빌더 패턴**
  1. 객체를 생성하는 데 사용
  2. 객체 생성 과정이 복잡할 때 객체를 생성하는 방법을 추상화하고, 각 단계마다 설정할 수 있는 메서드를 제공

---

# `wrapperclass( Wrapper 클래스 )란`

- 기본 데이터 타입을 객체로 감싸는 래퍼로, 기본 데이터 타입을 객체로 다루기 위해 사용
- 기본 데이터 유형에는 int, double, char, boolean 등이 있다.

  |기본 타입|Wrapper 클래스|
  |:---:|:---:|
  |byte|Byte|
  |char|Character|
  |int|Integer|
  |float|Float|
  |double|Double|
  |boolean|Boolean|
  |long|Long|
  |short|Short|

---

# `boxing과 unboxing`

- 기본 자료형 → Wrapper class로 변환하는 것을 박싱( Boxing )
- Wrapper class → 기본 자료형으로 변환하는 것을 언박싱( UnBoxing )이라 한다.

---

# `클래스 멤버 변수 초기화 순서`

#### **정적 변수(static variables)**
  - 클래스가 로드될 때 초기화

#### **인스턴스 변수(instance variables)**
  - 객체가 생성될 때 초기화

#### **생성자(Constructor)**
  - 객체가 생성될 때 생성자가 호출되어 인스턴스 변수의 초기화 작업이 완료

### **정적변수 -> 인스턴스 변수 -> 생성자**

---

# `static이란, static을 사용하는 이유는`

- 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용가능, 즉 인스턴스(객체) 생성 없이 바로 사용 가능
- 자주 변하지 않는 값, 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.

---

# `Inner Class(내부 클래스)의 장점`

- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근가능
- 외부 클래스의 멤버와 메서드를 상속하거나 확장하여 코드의 재사용성을 높여준다.
- 외부 클래스의 멤버에 대한 직접적인 접근을 제한하고, 내부 클래스를 사용하여 해당 멤버에 접근할 수 있도록 캡슐화 가능

---

# `제네릭이란?`

- 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정
- 컴파일러가 코드를 검사하여 타입 안전성을 보장
- 다양한 타입에 대해 동일한 코드를 재사용가능

---

# `직렬화(Serialize)란`

- ObjectOutputStream 클래스를 사용하여, 객체의 상태를 저장하거나 네트워크를 통해 전송하기 위해 객체를 바이트 스트림으로 변환하는 프로세스, 즉 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용 할 수 있도록 바이트 스트림(stream of bytes) 형태로 연속전송(serial) 데이터로 변환하는 포맷 변환 기술
- JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 파일이나 네트워크 전송 등을 통해 영속화
- ObjectInputStream 클래스를 사용하여, 객체를 다시 원래의 형태로 복원하는 것을 역직렬화(Deserialization)라고 한다.
- 직렬화된 객체는 파일이나 네트워크를 통해 전송되고, 역직렬화를 통해 다시 객체로 복원
- 직렬화 구현시 해당 클래스에 Serializable를 inplements 후 직렬화 버전 교유값( SerialVersionUID ) 넣기

---

# `SerialVersionUID를 선언해야 하는 이유`

- Serializable 인터페이스를 구현한 클래스의 객체를 직렬화할 때, Java는 클래스의 구조를 사용하여 객체를 저장하는데, 이 때 클래스의 구조는 클래스 이름, 필드 이름, 메서드 이름 등을 포함한다. 만약 필드가 추가 및 제거되거나 이름이 변경되는 클래스의 구조가 변경되면 이전에 직렬화된 데이터와 호환되지 않을 수 있다. 이러한 호환성 문제를 해결하기 위해 serialVersionUID라는 특별한 정적 변수를 사용
- 즉 직렬화된 객체의 버전을 식별하는 데 사용
- 직렬화된 객체의 버전과 클래스의 serialVersionUID를 비교하여 호환성을 검사

---

# `hashCode()란`

- 객체의 해시 코드를 반환하는 메서드, 객체를 해시 테이블과 같은 해시 기반 자료구조에 저장할 때 사용
- 모든 객체는 Object 클래스를 상속하므로, 모든 객체는 hashCode() 메서드를 가지고 있다.
- 일반적으로 객체의 메모리 주소나 내용에 기반하여 생성
- hashCode() 메서드를 오버라이딩할 때는 equals() 메서드와 일관성을 유지해야 한다.
- 서로 다른 객체가 같은 해시 코드를 가질 수 있다.

---

# `Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사의 방법은`

- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고, 해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교, 이 두 개가 모두 맞으면 중복 객체로 판단

---

# `리플렉션(Reflection)이란`

- 실행 중인 프로그램의 구조를 분석하고 수정할 수 있는 기능을 제공, 이를 통해 런타임 시에 클래스의 정보를 얻고 조작할 수 있다.
- 리플렉션 API를 통해 구체적인 클래스 타입을 알지 못해도 클래스, 메서드, 필드 등의 정보를 동적으로 검사하고 조작가능
- 강력한 기능이지만, 잘못 사용하면 성능 저하와 보안 취약점을 초래

---

# `리플렉션은 어떤 경우에 사용되는가`

- 런타임 시에 클래스 이름을 동적으로 결정해야 하는 경우
- 컴파일 시에 알 수 없는 클래스의 메서드를 호출해야 하는 경우
- 프로그램의 구조를 동적으로 분석하고 수정해야 하는 경우

---

# `싱글톤이란`

- 디자인 패턴 중 하나로, 해당 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴
- 어떤 상황에서든지 해당 클래스의 인스턴스를 공유하고 접근할 수 있다.
- 인스턴스가 필요한 시점에 생성

---

# `싱글톤 대표 예`

#### **Spring Bean**
  1. 싱글톤으로 빈(Bean)을 관리
  2. 컨테이너가 해당 빈을 한 번만 생성하고, 이후에는 동일한 인스턴스를 반환

#### **로깅 시스템**
  1. 싱글톤 패턴을 사용하여 로거( Logger ) 인스턴스를 관리
  2. 여러 부분에서 동시에 로깅을 수행할 때 일관된 로그 메시지를 유지하고, 리소스를 효율적으로 관리

---

# `Optional API란`

- 값이 없을 수도 있는 상황( null )에서 사용하는 클래스
- NullPointerException을 방지하고 코드를 안전하게 작성할 수 있도록 도와준다.

---

# `컬렉션 프레임워크란`

- 배열의 제한과 불편함을 극복하기 위해 제공
- 객체나 데이터를 효율적인 관리( 추가, 삭제, 검색, 정렬 등) 할 수 있는 자료구조들의 클래스와 인터페이스의 집합
- 종류로는 List, Set, Map, Queue 등이 있다.

---

# `참고문서`

[슬기로운 개발생활:티스토리](https://dev-coco.tistory.com/153)
