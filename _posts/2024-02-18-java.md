---
title: "자바 면접 질문"
author:
  name: 김병우
  link: https://github.com/Woob29
date: 2024-02-18 15:09:00 +0900
categories: [면접 질문, 자바]
---

# 자바의 특징과 장단점
- 캡슐화,상속,다형성이 잘 적용된 객체 지향 언어이다.
- 플랫폼이 독립적이다.
- 가비지 컬렉션 기능이 있다.   
  
#### **장점**
   1. 안정성과 보안성이 뛰어나다.
   2. 많은 라이브러리를 제공하여 다양한 개발에 용이하다.
   3. 가비지 컬렉션으로 메모리를 자동으로 관리한다.
   
#### ** 단점 **
   1. JVM에서 동작하기 때문에 느리다.
   2. 메모리 사용량이 높다.

- - -

# JVM 이란
- Java Virtual Machine( JVM )은 자바 바이트 코드를 실행하는 가상머신으로<br>
    스레드 관리, 가비지 컬렉션으로 메모리관리 등을 수행 한다.
- 각 운영 체제에 맞는 네이티브 코드를 생성하여 실행

- - -

# JDK와 JRE의 차이점
- 둘 다 자바 프로그램을 개발 및 실행하는 데 필요한 도구와 라이브러리  
   
#### ** JDK **
   1. 자바 애플리케이션을 개발할 때 필요한 모든 도구를 제공하는 패키지
   2. JDK는 JRE를 포함

#### ** JRE **
   1. 자바 애플리케이션을 실행할 때 필요한 환경을 제공하는 패키지
   2. 자바 애플리케이션을 실행하는 데 필요한 최소한의 요소만을 포함

- - -

# 자바의 원시타입 종류(기본자료형), 각각 차지하는 바이트
#### ** 정수형 **
   - byte(1), short(2), int(4), long(8)
  
#### ** 실수형 **
   - float(4), double(8)
  
#### ** 문자형 **
   - char(2)
  
#### ** 논리형 **
   -  boolean(1)

- - -

# oop(객체 지향 프로그래밍)란
- 소프트웨어 개발 및 설계 방식 중 하나로 객체가 중심인 누가 어떤 일을 할 것인가
- 클래스, 객체, 캡슐화, 상속, 다형성을 통해 코드의 재사용성, 유지보수성, 확장성을 향상시키는데 기여한다.

- - -

# 자바에서 클래스와 객체란
#### ** 클래스 **
   1. 객체를 만들기 위한 틀 또는 설계도
   2. 필드(선언된 데이터) + 메소드(함수) + 생성자로 구성
   3. 클래스는 다른 클래스로부터 상속을 받을 수 있으며, 상속을 통해 코드의 재사용성을 높일 수 있다.
   
#### ** 객체 **
   1. 클래스의 인스턴스 즉 구체적인 실체
   2. 객체는 메모리에 할당되어 사용
   3. 하나의 클래스로부터 여러 개의 객체를 생성가능

- - -

# 자바에서 상속이란(IS관계)
- 한 클래스가 다른 클래스의 특성(필드와 메서드)을 물려 받는 것을 의미
- 자식 클래스는 부모 클래스에서 정의된 필드와 메서드를 직접적으로 사용할 수 있으며,<br>
    필요한 경우에는 자식 클래스에서 새로운 필드나 메서드를 추가할 수 있다.
- 코드의 재사용성, 확장성, 다형성이 좋아진다.

- - -

# Has관계란
- 클래스가 다른 클래스의 객체를 포함하고 있는 경우
- 객체 간의 결합도를 느슨하게 유지(약한 결합)
- 클래스 간의 의존성이 낮다.

- - -

# 자바에서 다형성이란
- 객체 지향 프로그래밍 핵심 원리중 하나로 메소드의 오버로딩, 오버라이딩, 상속 등을 통해<br>
    코드의 유연성과 재사용성을 높일 수 있다.

- - -

# 참조 자료형 변환이란
- 객체 지향 프로그래밍에서 한 타입의 참조 변수를 다른 타입의 참조 변수로 변환하는 것
- 상속이 있어야 할 수 있다.
- 업 캐스팅(upcasting)과 다운 캐스팅(downcasting)
#### ** 업 캐스팅 **
   1. 객체는 자식인데 변수 자료형 부모인 경우
   2. 항상 안전하며, 명시적으로 형변환하지 않아도 됨

#### ** 다운 캐스팅 **
   1. 변수의 자료형이 부모였는데 다시 본인 자료형으로 바꾸는 경우
   2. 명시적으로 형변환을 해야하며, 실행 시간에 발생하는 유형 확인과 캐스트 예외가 발생가능
   3. 잘못된 형변환 시 ClassCastException이 발생가능

- - -

# 자바에서 캡슐화란
- 객체지향 프로그래밍의 핵심 개념 중 하나
-  데이터와 해당 데이터를 처리하는 메서드를 하나로 묶는 것으로 <br>
    객체의 내부 상태를 보호 및 외부 접근 제어

- - -

# 접근 제한자란
- 캡슐화를 구현하는 데 사용되는 도구 중 하나
- 클래스, 메서드, 필드 등의 멤버에 대한 접근 권한을 제어하는 데 사용
- 1번 ~ 4번 범위 크기 (큰 범위 ~ 작은 범위)  
   
#### ** public **
   - 공용, 누구나 사용 가능
  
#### ** protected **
   - 상속받은 클래스만 사용 가능
  
#### ** default **
   - 같은 패키지 내에서만 사용 가능

#### ** private **
   - 해당 멤버를 선언한 클래스 내에서만 사용 가능(상속 관계에서도 접근 불가)
  
- - -

# 생성자란
- 객체를 생성할 때 호출되는 특수한 종류의 메서드로 객체의 초기화를 위해 사용, 생성될때 자동 호출
- 명시적으로 정의하지 않으면 컴파일러가 기본 생성자를 자동으로 제공
- 상속되지 않음
- 오버로딩 가능

- - -

# 생성자와 매소드 같은점과 다른점
#### ** 같은점 **
   - 매개변수 사용이 가능하다.
   - 반복문이나 조건문을 사용해여 기능 구현이 가능하다.

#### ** 다른점 **
   - 생성자는 객체를 초기화하는 데 사용되며 반환 유형이 없고, 이름을 마음대로 정할 수 없으며,<br>
        객체를 생성할 때 한 번만 호출된다.
   - 매서드는 객체의 동작을 정의하며, 이름을 정할 수 있고, 반환 유형이 있다.
 
 - - -

# 오버라이딩과 오버로딩이란
#### ** 오버라이딩 **
   - 상위 클래스(부모 클래스)의 메서드를 하위 클래스(자식 클래스)에서 재정의하는 것을 의미

#### ** 오버로딩 **
   - 같은 이름의 메서드를 여러 개 정의하고, 매개변수의 개수나 타입을 다르게하여 다양한 형태의 호출을 지원하는 것을 의미

- - -

# 객체지향의 설계원칙
#### ** SRP ( 단일 책임 원칙 ) **
   - 한 클래스는 하나의 책임만 가져야 한다.

#### ** OCP ( 개방-폐쇄 원칙 ) **
   - 확장에는 열려있고, 수정에는 닫혀있어야 한다.

#### ** LSP ( 리스코프 치환 원칙 ) **
   - 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.

#### ** ISP ( 인터페이스 분리 원칙 ) **
   - 인터페이스 내에 메소드는 최소한 일수록 좋다.

#### ** DIP ( 의존관계 역전 원칙 ) **
   - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. 

- - -

# 자바 바이트 코드(java bytecode)란
- 자바 가상 머신 (JVM)이 이해할 수 있는 중간 언어
- 자바 소스 코드를 컴파일 하여 생성된 코드
- 특정 플랫폼에 의존하지 않으며, 여러 플랫폼에서 동일하게 실행

- - -

# 가비지컬렉션(Garbage Collection)이란
- 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 메모리(가비지(Garbage))를<br>
    자동으로 해제하는 메모리 관리 기법
- 메모리 누수 방지, 프로그램의 안정성을 높여준다.
- 단점으로는 개발자가 메모리가 언제 해제되는지 알 수 없다.
- 가비지컬렉션이 동작하는동안 다른 동작을 멈추기 때문에 오버헤드 발생가능

- - -

# 가비지컬렉션 과정
- JVM 실행을 일시적으로 멈추고 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후<br>
    사용하지 않는 메모리를 제거 후 작동 재개

- - -

# 자바에서 스레드란
- 프로그램의 실행 흐름을 나타내는 가장 작은 단위
- 각각의 스레드는 독립적으로 실행되며, 서로 다른 작업을(동시에) 수행가능
- 멀티코어 프로세서를 활용하여 여러 스레드가 병렬로 실행가능

- - -

# 자바와 C++의 차이점
#### ** 자바 **
   - 메모리 자동관리, 플랫폼 독립적, 느린 실행속도

#### ** c++ **
   - 메모리 직접관리, 플랫폼 종속적, 빠른 실행속도

- - -

# 자바의 메모리 영역이란
#### ** 힙(Heap) 영역 **
  1. 객체와 배열이 동적으로 할당되는 영역으로 가비지 컬렉션의 대상이 되며, 가비지 컬렉터에 의해 관리된다
  2. 할당 시점 -> 런타임시 할당

#### ** 스택(Stack) 영역 **
  1. 메서드 호출과 지역 변수들이 저장되는 영역으로 메서드 호출 시 마다 <br>
        호출 스택 프레임이 생성되어 호출 정보와 지역 변수들을 저장
  2. 할당 시점 -> 메소드가 호출될 때 할당

#### ** 메서드(Method Area 또는 PermGen) 영역 **
  1. 메서드 영역은 클래스의 구조(메서드와 필드의 정보), 정적 변수, 상수, 메서드 코드 등을 저장하는 영역
  2. 할당 시점 -> JVM이 동작해서 클래스가 로딩될 때 생성

- - -

# 자바에서 동기화란
- 여러 스레드가 공유된 자원 또는 데이터에 동시에 접근할 때 발생할 수 있는 문제를 해결하기 위한 메커니즘
- 여러 스레드 간의 데이터 일관성을 보장하기 위해 사용
- 한 번에 하나의 스레드만 실행되며, 다른 스레드들은 해당 블록이나 메서드가 실행 완료될 때까지 대기
- 스레드 간의 실행 순서를 제어하여 데이터의 일관성을 유지하고 경쟁 조건(Race Condition)을 방지가능
- 주요 동기화 매커니즘으로는 synchronized 키워드,  ReentrantLock 클래스가 있다.

- - -

# synchronized란
- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 <br>
    나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념
- 동기화된 블록 또는 메서드 내에서는 한 번에 하나의 스레드만 실행되며, <br>
    다른 스레드는 해당 블록이나 메서드의 실행이 완료될 때까지 대기
- 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있다.

- - -

# ReentrantLock 클래스란
- synchronized키워드의  단점을 극복하기 위한 대안으로 도입, 세밀한 동기화 제어가 가능
- 진입 가능한(lock) 잠금을 제공하며, 공정한 잠금 획득을 지원 및 조건 변수를 사용하여 스레드의 상태를 기다리고 조절가능
- 시간 제한을 두고 잠금을 시도를 통해 성능 향상 및 데드락 방지 가능

- - -

# 데드락이란
- 두 개 이상의 스레드가 서로 상대방의 자원을 기다리며 무한히 대기하는 상태
- 예방을 위해 상호배제, 점유대기, 비선점, 순환대기 등의 조건을 만족시키지 않도록 주의

- - -

# 공정한 잠금(Fair Lock) 이란
- 다중 스레드가 잠금을 획득하는 순서를 제어하는 방식
- 여러 스레드가 잠금을 획득하려고 시도할 때, 이를 기다리는 순서가 정해져 있어서 <br>
    어떤 스레드도 계속해서 잠금을 획득하지 못하는 현상을 방지

- - -

# 클래스와 인터페이스의 차이점
- 클래스는 필드, 메서드, 생성자 등을 포함하며 구현 가능, 단일 상속, 상태와 행동을 가지고 있는 객체를 만들기 위한 틀
- 인터페이스는 추상 메서드의 집합으로 구현 불가능, 다중상속 가능, 특정 기능을 정의하는데 사용

- - -

# 추상화란
- 객체의 공통된 특성을 추출하여 일반화시키는 과정
- 데이터나 프로세스의 복잡성을 숨기고 필요한 부분만을 강조하여 표현하는 것을 의미
- 추상화 방법으로는 추상 클래스, 인터페이스가 있다.
- 필수적으로 상속을 해야한다.

- - -

# 추상클래스와 인터페이스의 공통점과 차이
#### ** 공통점 **
  1. 인스턴스 생성 불가능
  2. 하위 클래스에서 확장/구현 해야 사용 가능

#### ** 추상클래스 **
  1. 일반 클래스와 비슷하지만, 추상 메서드를 포함할 수 있다.
  2. 단일 상속만 가능
  3. 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용

#### ** 인터페이스 **
  1. 추상 메서드만을 포함 가능, 모든 메서드가 추상 메서드이므로 일반 필드를 가질 수 없다.
  2. 다중 상속 가능
  3. 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제

- - -

# try-catch-finally란
- 예외 처리를 위한 구문
- try에서 예외 발생시 예외에 관련한 catch로 이동, 예외발생 여부에 상관없이 finally에서 항상 코드 실행
- finally 블록은 주로 리소스 해제와 관련된 코드를 작성

- - -

# try-with-resources란
- try-catch-finally의 문제점을 보완하기 위해 나온 개념
- 자원을 사용한 후에 finally 블록이나 명시적으로 리소스를 해제하는 코드를 작성할 필요 없이, 자원을 자동으로 해제 가능
- AutoCloseable 인터페이스를 구현한 리소스를 사용할 때 자동으로 리소스를 해제

- - -

# Error와 Exception의 차이
#### ** Error **
  1. 프로그램에서 복구할 수 없는 치명적인 오류
  2. 컴파일 시간에는 확인할 수 없고, 오류가 발생하면 프로그램이 비정상적으로 종료될 수 있다.
  3. Unchecked Exception에 해당

#### ** Exception **
  1. 프로그램 실행 중에 발생하는 예외
  2. try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

- - -

# CheckedException과 UnCheckedException의 차이
- 예외를 처리하는 방법을 나타내는 데 사용
  
#### ** Checked Exception (검사 예외) **
  1. 컴파일 시점에 확인되는 예외로, 반드시 예외를 처리 필요
  2. 대표적인 예로 IOException, SQLException 등

#### ** UnCheckedException(비검사 예외 또는 런타임 예외) **
  1. 컴파일 시점에 확인되지 않는 예외로,  예외 처리를 선택적으로 할 수 있다.
  2. 주로 프로그램의 오류나 개발자의 실수로 인해 발생
  3. 대표적인 예로 NullPointerException, IllegalArgumentException 등

- - -

# String, StringBuffer, StringBuilder의 차이
#### ** String **
  1. 불변(immutable)한 클래스
  2. 멀티 스레드 환경에서 안전

#### ** StringBuffer **
  1. 가변(mutable)한 클래스
  2. 동기화되어 멀티스레드에서 사용

#### ** StringBuilder **
  1. 가변(mutable)한 클래스
  2. 동기화되지 않아 싱글스레드에서 사용
  3. 동기화에 대한 오버헤드가 없음

- - -

# String 객체가 불변인 이유
#### ** 보안 **
  - 문자열이 한 번 생성되면 그 값을 변경할 수 없으므로 중요한 정보가 변경되는 것을 방지
  
#### ** 스레드 안전성 **
  - 불변한 문자열은 한 번 생성된 후에 변경되지 않으므로 여러 스레드가 동시에 문자열을 읽어도 안전
  
#### ** 캐싱 **
  - 동일한 문자열 리터럴은 동일한 문자열 객체를 참조하므로 중복된 문자열 리터럴이 <br>
    메모리에 여러 번 생성되지 않아 메모리 사용을 최적화하고 성능을 향상

- - -

# 불변객체란 무엇이고 사용해야하는 이유는
- 한 번 생성되면 내부 상태가 변경될 수 없는 객체, 주로 함수형 프로그래밍과 멀티스레드 환경에서 사용
- 프로그램의 안전성과 유지 보수성을 높이는 데 도움
- String 클래스와 Integer 클래스, final 키워드를 사용해 불변 객체를 만들 수 있다
- 특징으로는 내부 상태 변경 불가능, 스레드 안전성, 캐싱, 객체 공유 가능

- - -

# final / finally / finalize 의 차이
#### ** final **
  1. 클래스, 메소드, 변수, 인자를 선언할 때 사용
  2. 한 번 초기화되면 다시 할당할 수 없다.

#### ** finally **
  1. 예외 처리(try-catch) 블록에서 사용되며, 항상 실행되어야 하는 코드를 정의
  2. 주로 리소스 해제나 정리 코드를 finally 블록에 포함하여 안전하게 처리

#### ** finalize **
  1. 객체 소멸 직전에 호출되는 메서드
  2. 객체가 가비지 컬렉션될 때 호출되며, 해당 객체가 사용한 리소스를 해제하거나 정리하는 등의 마무리 작업을 수행 가능
  3. 호출 시점은 보장되지 않기 때문에 자원을 해제하는 용도로 사용하기보다는 GC의 동작을 보조하는 용도로 사용

- - -

# new String()과 리터럴("")의 차이
- 문자열 리터럴("")은 자바의 String Pool에 저장
- new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장

- - -

# 재귀함수란
- 함수가 자신을 호출하는 것을 허용하는 함수
- 반복적인 작업을 해결하는 데 사용
- 무한 루프에 빠지지 않도록 종료 조건을 잘 설정해야 하며, 재귀 호출의 깊이가 너무 깊어지지 않도록 주의해야 한다.

- - -

# Math.round()란
- float 또는 double 타입(실수)의 값을 매개변수로 받아서 가장 가까운 정수로 반올림한 값을 반환

- - -

# 자바에서 람다식이란
- 함수형 프로그래밍 기법으로, 익명 함수를 생성하기 위한 간결한 문법을 제공
- 코드의 간결성과 가독성을 높아진다.

- - -

# 자바에서 Stream API란
- 컬렉션을 함수형 프로그래밍의 스트림으로 처리하는 기능을 제공
- 스트림은 데이터의 흐름을 추상화한 것으로, 여러 종류의 데이터 소스(컬렉션, 배열, 파일 등)로부터 <br>
    데이터를 읽고 쓰는데 사용
- 데이터를 처리하는 작업을 병렬로 처리하거나 간결하게 표현 가능

- - -

# wrapperclass(Wrapper클래스)란
- 기본 데이터 유형을 객체로 감싸는 래퍼로, 기본 데이터 유형을 객체로 다루기 위해 사용
- 기본 데이터 유형에는  int, double, char, boolean 등이 있다.

- - -

# boxing, unboxing이란
- 기본 자료형 → Wrapper class로 변환하는 것을 Boxing이라 하며,<br>
    Wrapper class → 기본 자료형으로 변환하는 것을 UnBoxing이라 한다.

- - -

# 클래스 멤버 변수 초기화 순서
#### ** 정적 변수(static variables) **
  - 클래스가 로드될 때 초기화

#### ** 인스턴스 변수(instance variables) **
  - 객체가 생성될 때 초기화

#### ** 생성자(Constructor) **
  - 객체가 생성될 때 생성자가 호출되어 인스턴스 변수의 초기화 작업이 완료

#### ** 정적변수 -> 인스턴스 변수 -> 생성자 **

- - -

# static이란, static을 사용하는 이유는
- 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용가능<br>
    즉, 인스턴스(객체) 생성 없이 바로 사용 가능
- 자주 변하지 않는 값, 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 값을 읽어들이는 <br>
    것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.

- - -

# Inner Class(내부 클래스)의 장점
- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근가능
- 외부 클래스의 멤버와 메서드를 상속하거나 확장하여 코드의 재사용성을 높여준다.
- 외부 클래스의 멤버에 대한 직접적인 접근을 제한하고, 내부 클래스를 사용하여 해당 멤버에 접근할 수 있도록 캡슐화 가능

- - -

# 제네릭이란?
-  데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정
- 컴파일러가 코드를 검사하여 타입 안전성을 보장
-  다양한 타입에 대해 동일한 코드를 재사용가능

- - -

# 직렬화(Serialize)란
- 객체의 상태를 저장하거나 네트워크를 통해 전송하기 위해 객체를 바이트 스트림으로 변환하는 프로세스, <br>
    ObjectOutputStream 클래스를 사용
- 객체를 다시 원래의 형태로 복원하는 것을 역직렬화(Deserialization), ObjectInputStream 클래스를 사용
- JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

- - -

# SerialVersionUID를 선언해야 하는 이유
- Serializable 인터페이스를 구현한 클래스의 객체를 직렬화할 때, Java는 클래스의 구조를 사용하여 객체를 저장하는데,<br>
    이 때 클래스의 구조는 클래스 이름, 필드 이름, 메서드 이름 등을 포함한다. 만약 필드가 추가 및 제거되거나 <br>
    이름이 변경되는 클래스의 구조가 변경되면 이전에 직렬화된 데이터와 호환되지 않을 수 있다. <br>
    이러한 호환성 문제를 해결하기 위해 serialVersionUID라는 특별한 정적 변수를 사용
- 즉 직렬화된 객체의 버전을 식별하는 데 사용
- 직렬화된 객체의 버전과 클래스의 serialVersionUID를 비교하여 호환성을 검사

- - -

# Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사의 방법은
- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,<br>
    해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교, 이 두 개가 모두 맞으면 중복 객체

- - -

# hashCode()란
- 객체의 해시 코드를 반환하는 메서드, 객체를 해시 테이블과 같은 해시 기반 자료구조에 저장할 때 사용
- 모든 객체는 Object 클래스를 상속하므로, 모든 객체는 hashCode() 메서드를 가지고 있다.
- 일반적으로 객체의 메모리 주소나 내용에 기반하여 생성
- hashCode() 메서드를 오버라이딩할 때는 equals() 메서드와 일관성을 유지해야 한다.
- 서로 다른 객체가 같은 해시 코드를 가질 수 있다.

- - -

# 리플렉션(Reflection)이란
- 실행 중인 프로그램의 구조를 분석하고 수정할 수 있는 기능을 제공, 이를 통해 런타임 시에 클래스의 정보를 얻고 조작할 수 있다.
- 리플렉션 API를 통해 구체적인 클래스 타입을 알지 못해도 클래스, 메서드, 필드 등의 정보를 동적으로 검사하고 조작가능
- 강력한 기능이지만, 잘못 사용하면 성능 저하와 보안 취약점을 초래

- - -

# 리플렉션은 어떤 경우에 사용되는가
- 런타임 시에 클래스 이름을 동적으로 결정해야 하는 경우
- 컴파일 시에 알 수 없는 클래스의 메서드를 호출해야 하는 경우
- 프로그램의 구조를 동적으로 분석하고 수정해야 하는 경우

- - -

# 싱글톤이란
- 디자인 패턴 중 하나로, 해당 클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴
- 어떤 상황에서든지 해당 클래스의 인스턴스를 공유하고 접근할 수 있다.
- 인스턴스가 필요한 시점에 생성

- - -

# 싱글톤 대표 예
#### ** Spring Bean **
   - 싱글톤으로 빈(Bean)을 관리
   - 컨테이너가 해당 빈을 한 번만 생성하고, 이후에는 동일한 인스턴스를 반환

#### ** 로깅 시스템 **
   - 싱글톤 패턴을 사용하여 로거(Logger) 인스턴스를 관리
   - 여러 부분에서 동시에 로깅을 수행할 때 일관된 로그 메시지를 유지하고, 리소스를 효율적으로 관리

- - -

# Optional API란
- 값이 없을 수도 있는 상황에서 사용하는 클래스
- NullPointerException을 방지하고 코드를 안전하게 작성할 수 있도록 도와준다.

- - -

# 컬렉션 프레임워크란
- 데이터를 저장하고 관리하는 자료 구조를 표현하는 데 사용되는 클래스와 인터페이스의 집합
- 데이터를 저장하고 조작하는 데 필요한 다양한 자료 구조를 제공하며, 데이터의 추가, 삭제, 검색 및 <br>
    정렬 등의 작업을 쉽게 수행할 수 있도록 지원

- - -

# 참고문서
[슬기로운 개발생활:티스토리](https://dev-coco.tistory.com/153)