---
title: "Spring 공통 면접 개념정리"
author:
  name: 김병우
  link: https://github.com/Woob29
date: 2024-02-24 03:00:00 +0900
categories: [개념정리, Spring]
---

### Spring Framework란?

- 자바 기반의 오픈 소스 애플리케이션 프레임워크
- 경량 컨테이너로서 애플리케이션의 시작 시간과 메모리 사용량이 적다.
- 의존성 주입을 통해 객체 간의 결합도를 낮추고 유연한 코드를 작성할 수 있도록 지원
- 관점 지향 프로그래밍을 지원하여 핵심 비즈니스 로직과 횡단 관심사(로깅, 트랜잭션 관리)를 분리 가능
- MVC 웹 프레임워크를 제공

---

### AOP( 관점지향 프로그래밍)이란?

- 객체 지향 프로그래밍을 돕는 보조적인 기술로, 핵심 관심 사항과 공통 관심 사항을 분리해서 각각을 모듈화 하는 것
- 코드의 중복을 줄이고, 유지보수성을 향상
- 주로 로깅, 트랜잭션 관리, 보안, 성능 모니터링 등과 같은 부가적인 기능을 적용할 때 사용

---

### Spring과 Spring Boot의 차이점은?

- 둘 다 Spring Framework의 일종

`Spring`

1. 프로젝트를 설정하고 구성하는 일이 상대적으로 복잡하다.
2. 서블릿 컨테이너( Tomcat, Jetty )를 따로 설치하고 구성
3. 데이터베이스 연결, 트랜잭션 관리, 보안 설정 등의 기본적인 기능을 직접 설정
4. 개발자가 많은 구성 작업을 수동으로 수행해야 하므로 생산성이 다소 떨어질 수 있다.
5. 상대적으로 복잡하지만 높은 유연성을 제공

`Spring Boot`

1. 의존성 세트를 사용하여 프로젝트 설정을 자동화
2. 내장된 서버( Tomcat, Jetty, Undertow )를 기본적으로 제공하여 별도의 서버 설정 없이도 애플리케이션을 실행
3. 개발자가 필요로 하는 많은 설정을 자동화하여 제공
4. 초기 설정에 더 적은 시간을 소비, 복잡한 구성 작업을 자동화하기 때문에 생산성이 크게 향상될 수 있다.
5. 빠르고 간편한 애플리케이션 개발을 위해 만들어진 Spring의 확장

---

### Spring Framework의 빌드도구 종류는?

`Apache Maven`

- 프로젝트 관리, 의존성 관리, 라이브러리 관리 등을 지원
- pom.xml 파일을 사용하여 프로젝트의 설정과 의존성을 관리

`Gradle`

- Maven과 유사하지만 Groovy 기반 DSL(Domain-Specific Language)을 사용하여 빌드 스크립트를 작성
- Maven보다 유연하고 간결한 문법을 제공하며, 빌드 성능이 더 우수

---

### 빈(Bean) 이란?

- 단순히 스프링 애플리케이션 컨텍스트에 등록된 객체
- 비즈니스 로직, 데이터베이스 연결, 트랜잭션 관리 등의 역할을 수행
- 스프링 컨테이너에 등록되어 관리
- 스프링 컨테이너에 의해 생성되고 초기화되며, 애플리케이션이 종료될 때 소멸

---

### 스프링 컨테이너(Spring Container)란?

- 스프링 애플리케이션의 객체를 생성, 관리, 제거하는 책임을 담당
- 애플리케이션의 객체들을 빈(Bean)으로 관리
- 애플리케이션의 라이프사이클을 관리하고 의존성 주입(Dependency Injection)을 수행

---

### 스프링 컨테이너의 생명주기는?

1. 생성(Instantiation)

- 스프링 설정 파일을 로드하고, 설정에 정의된 빈(Bean)들을 생성하고 구성

2. 구성(Configuration)

- 설정 파일에 정의된 빈들을 인스턴스화하고, 필요한 의존성을 주입

3. 초기화(Initialization)

- 각 빈의 초기화 메서드를 호출하여 빈을 준비

4. 사용(Usage)

- 클라이언트 애플리케이션이 스프링 컨테이너로부터 빈을 검색하고, 이를 사용하여 비즈니스 로직을 수행

5. 소멸(Destruction)

- 각 빈의 소멸 메서드가 호출되어 빈이 종료

---

### 스프링 프레임워크의 필수 구성 요소는?

`제어의 역전( IoC, Inversion of Control )`

1. 소프트웨어 설계 원칙 중 하나로, 프로그램의 제어 흐름을 개발자가 아닌 프레임워크나 컨테이너가 담당하는 디자인 패턴
2. 객체의 생명주기를 관리하고 객체 간의 의존성을 해결하기 위해 사용
3. 모든 객체에 대한 제어권을 IoC 컨테이너에게 넘긴 것.

`의존성 주입( DI, Dependency Injection )`

1. 객체 간의 의존 관계를 코드 내에서 직접 설정하는 것이 아니라 외부에서 주입하는 디자인 패턴
2. 객체 간의 결합도를 줄이고 유연한 코드를 작성가능
3. 코드의 재사용성, 유연한 구성, 테스트 용이성, 단일 책임 원칙의 장점이 있다.

`AOP( Aspect-Oriented Programming )`

1. 스프링 프레임워크에서 제공하는 기능 중 하나로 관점 지향 프로그래밍을 지원하는 기술
2. 로깅, 보안, 트랜잭션 관리 등과 같은 공통적인 관심사를 모듈화 하여 코드 중복을 줄이고 유지 보수성을 향상

---

### application.properties란

- 스프링 부트 프로젝트에서 프로젝트의 환경 설정을 정의하고 구성하는 데 사용 되는 설정파일
- 주로 데이터베이스 연결 정보, 포트 번호, 외부 서비스의 인증 키 등과 같은 설정을 저장
- 시작될 때 해당 파일의 내용이 로드되어 애플리케이션의 동작을 구성

---

### @Value란?

- 스프링 프레임워크에서 프로퍼티 값을 주입받을 때 사용
- application.properties 또는 application.yml에 정의된 값을 가져와서 필드에 주입할 때 사용
- 주로 스프링 빈의 필드, 생성자 매개변수, 메서드 매개변수에 사용

---

### DDL AUTO 옵션 종류는?

`create`

- 시작 시에 기존 테이블을 삭제하고 새로운 테이블을 생성
- 개발 환경에서만 사용 권장

`update`

- 데이터베이스에 있는 테이블을 변경된 부분만을 반영하고 나머지는 그대로 유지
- 테이블이 존재하지 않으면 생성
- 개발 및 테스트 환경에서 사용 권장

`validate`

- 엔티티 클래스와 데이터베이스 스키마가 일치하는지 확인
- 변경된 부분이 있다면 경고 메시지를 출력

`none`

- 자동으로 데이터베이스 스키마를 관리하지 않는다.
- 데이터베이스 스키마를 직접 관리해야 한다.

---

### @AutoConfigureMockMvc란

- Spring Boot 테스트에서 MockMvc를 자동으로 구성하는 데 사용
- 서블릿 컨테이너를 시작하지 않고도 Spring MVC 컨트롤러를 테스트할 수 있도록 해주는 Spring의 테스트 지원 클래스

---

### 스프링 시큐리티( Spring Security )란?

- 스프링 기반의 애플리케이션에서 보안을 구현하기 위한 강력한 프레임워크
- 인증( 신원확인 )과 인가( 접근 권한 )를 처리하는 데 사용
- CSRF 공격을 방어하기 위한 기능을 제공
- 사용자 세션을 관리하고, 세션 유지, 세션 제한, 세션 타임아웃 등 다양한 세션 관련 기능을 제공
- 보안 관련 이벤트를 발생시키고, 해당 이벤트를 처리하는 리스너를 등록할 수 있다.

---

### UserDetail과 UserDetailsService란?

`UserDetails`

1. 스프링 시큐리티에서 사용자의 상세 정보를 표현하는 인터페이스
2. 사용자의 인증에 필요한 정보를 제공하는 역할을 수행

`UserDetailsService`

1. 스프링 시큐리티에서 사용자 정보를 로드하는 데 사용되는 인터페이스 구현체
2. 사용자 정보를 데이터베이스나 외부 소스에서 가져오는 역할을 수행
3. loadUserByUsername 메서드를 구현 후 UserDetails 객체로 반환해야 한다.

---

### OAuth 2.0 동작 흐름

1. 사용자가 클라이언트에게 인증 요청
2. 클라이언트가 인증서버에게 인가 코드 요청
3. 클라이언트가 사용자를 인증 엔드포인트(로그인 팝업)로 사용자 Redirect
4. 사용자가 인증서버에 로그인 시도
5. 인증 서버는 사용자에게 권한 부여 승인 코드 전달
6. 클라이언트가 인증서버에게 Access Token 요청 및 받기
7. 클라이언트가 액세스 토큰 사용하여 Resource Sever에게 보호된 자원 요청
8. Resource Sever에서 제공한 토큰 검증 후 인가 및 리소스 제어

---

### 영속성 프레임워크( Persistence Framework )란?

- 영속성이란 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성
- 영속성 프레임워크란 이러한 영속성을 관리하는 기술을 제공하는 소프트웨어 프레임워크
- 대표적인 영속성 프레임워크로는 SQL Mapper와 ORM으로 나눌 수 있다.

---

### ORM( Object-Relational Mapping )이란?

- 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터 변환을 자동화하는 프로그래밍 기법
- 객체와 관계형 데이터베이스 간의 불일치를 해결하기 위해 매핑( mapping )을 사용
- 객체 간의 관계를 표현함으로 SQL문을 작성하지 않고 데이터베이스 조작 가능
- SQL 쿼리를 직접 작성하지 않아도 되지만 복잡한 SQL 쿼리 처리가 어렵다.

---

### JPA( Java Persistence API )란

- ORM기술의 한종류로, 객체지향 프로그래밍 언어인 자바와 관계형 데이터베이스 간의 불일치를 해결하기 위해 개발
- ORM을 사용하기 위한 표준 인터페이스들의 집합
- JPA기능으로는 객체-관계 매핑(ORM), 트랜잭션 관리, 엔티티관리, JPQL 등이 있다.
- 객체지향적인 접근이 가능하고, 특정 데이터베이스에 종속되지않는 플랫폼 독립성의 장점이 있다.
- 실제 애플리케이션은 데이터베이스와 상호 작용하므로 특정 데이터베이스에 종속적 일 수 있다.
- 가장 널리 사용되는 구현체로는 Hibernate, EclipseLink, OpenJPA 등이 있다.

`동작방식`

1. 엔티티 클래스 정의
2. 엔티티 매니저 팩토리 생성
3. 엔티티 매니저 생성
4. 트랜잭션 관리
5. CRUD 작업 수행
6. JPQL 쿼리 실행
7. 영속성 컨텍스트 관리

---

### JPA 연관관계 매핑이란?

- 객체 간의 관계를 데이터베이스의 테이블 간의 외래키로 매핑하는 과정

`단방향 관계 (Unidirectional Relationship)`

- 단방향 관계는 한 객체가 다른 객체를 참조하거나 연결하는 방향으로만 관계가 정의
- 한 객체가 다른 객체를 참조하고 있지만, 참조된 객체는 참조를 반대로 하지 않는다.

`양방향 관계 (Bidirectional Relationship)`

- 두 객체가 서로를 참조하는 방향으로 관계가 정의
- 한 객체가 다른 객체를 참조하고 있을 뿐만 아니라, 반대로 다른 객체도 첫 번째 객체를 참조

`일대일 관계 (One-to-One Relationship)`

- 한 객체가 다른 객체와 일대일로 관련되어 있는 관계
- @OneToOne 사용

`일대다 관계 (One-to-Many Relationship)`

- 한 객체가 다른 객체와 일대다로 관련되어 있는 관계
- @OneToMany 사용

`다대일 관계 (Many-to-One Relationship)`

- 여러 객체가 다른 한 객체와 다대일로 관련되어 있는 관계
- @ManyToOne 사용

`다대다 관계 (Many-to-Many Relationship)`

- 여러 객체가 다른 여러 객체와 다대다로 관련되어 있는 관계
- @ManyToMany 사용

---

### JPA N + 1 문제와 발생하는 이유 그리고 해결하는 방법

- 연관 관계가 있는 Entity를 조회할 경우에, 결과로 조회된 데이터 개수(N)만큼 연관 관계가 있는 데이터를 추가로 조회하는 쿼리를 발생시키는 문제
- 일대다 또는 다대일 관계에서 한 엔티티를 조회할 때 연관된 많은 엔티티가 있는 경우 발생할 수 있다.
- 지연 로딩이 설정된 경우, 엔티티를 조회할 때마다 연관된 엔티티를 추가적으로 로딩하기 위해 쿼리가 실행

`해결방법`

1. Fetch Join
   - JPQL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법

2. @BatchSize
   - 일괄 쿼리 실행을 통해 한 번에 여러 엔티티를 로딩

3. QueryBuilder 사용
   - Query의 실행을 지원하는 다양한 플러그인(Mybatis, QueryDSL 등)사용

---

### JPQL( Java Persistence Query Language )이란?

- JPA에서 사용되는 객체 지향 쿼리 언어
- 엔티티(Entity) 객체를 대상으로 하는 쿼리를 작성하는 데 사용
- 엔티티를 검색하고 필터링하며, 엔티티 간의 관계를 활용하여 복잡한 쿼리를 작성

---

### 영속성 컨텍스트( Persistence Context )란?

- JPA에서 관리되는 엔티티의 상태를 저장하고 관리하는 논리적인 작업 영역
- 애플리케이션과 DB 사이에서 객체를 보관하는 가상 DB 역활
- 엔티티 매니저를 통해 생성되며, 트랜잭션 범위 내에서 엔티티의 생명주기를 관리

`사용시 이점`

1. 1차 캐시, 지연 로딩을 활용한 성능 향상
2. 변경감지를 통한 데이터 일관성을 유지
3. 객체의 동일성을 보장

---

### Hibernate란?

- JPA 구현체 중 하나
- 객체-관계 매핑(ORM) 프레임워크 중 하나
- 객체-관계 매핑을 처리하고, 데이터베이스 액세스를 추상화하여 개발자가 SQL 쿼리를 직접 작성하는 번거로움을 덜어준다.

`ORM -> JPA -> Hibernate`

- ORM기술을 구현하기 위해 JPA API사용, JPA를 구현하기 위해 여러 ORM 프레임워크 중 하나인 Hibernate 사용

---

### SQL Mapper

- 데이터베이스와 자바 객체 간의 매핑을 하여 데이를 객체화 하는 기술
- SQL 구문을 직접 작성해야 하지만 그대로 사용하기에 복잡한 쿼리(조인 등)를 좀 더 수월하게 작성 가능

---

### JDBC( Java Database Connectivity )란?

- 자바 프로그램이 관계형 데이터베이스와 상호 작용할 수 있도록 하는 저수준의 자바 API
- 데이터베이스에 연결하고 쿼리를 실행하며 결과를 가져오는 데 사용
- 데이터베이스 연결, 쿼리 실행, 결과 처리 등을 직접 다루어야한다.

---

### MyBatis란?

- 객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는 개발 프레임 워크
- JDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화
- 프로그램에 있는 SQL쿼리들을 한 구성파일에 구성하여 프로그램 코드와 SQL을 분리할 수 있는 장점이 있다.
- 복잡한 쿼리나 다이나믹한 쿼리에 강하지만 비슷한 쿼리는 남발하게 되는 단점이 있다.

`SQL Mapper -> JDBC -> MyBatis`

- SQL Mapper 기술을 사용하기 위해 JDBC API 사용, JDBC를 사용하기위해 여러 SQL Mapper 프레임워크 중 하나인 MyBatis 사용

---

### Repository란?

- JPA에서 사용되는 인터페이스로, 데이터베이스와의 상호작용을 추상화하고 데이터 액세스를 단순화하는 데 사용
- 데이터베이스에서 엔티티를 조회, 저장, 수정, 삭제하는 메서드를 정의
- JPA는 Repository 인터페이스를 구현하는 구현체를 자동으로 생성하여 빈으로 등록해주는 기능을 제공
- findById, findAll, save, delete 와 같은 주요 메서드 제공

---

### DTO와 Entity의 차이는?

- 데이터를 표현하는 데 사용되는 두 가지 다른 개념

`DTO( Data Transfer Object )`

1. 데이터 전송 객체로, 주로 데이터를 전송하거나 전달하기 위해 사용
2. 일반적으로 데이터를 가지고만 있고, 비즈니스 로직이나 동작을 포함하지 않는다.
3. 주로 읽기 전용 데이터로 사용

`Entity`

1. 데이터베이스에서 영구적으로 저장되는 도메인 모델의 일부
2. 데이터베이스와 매핑
3. 애플리케이션에서 관리되는 실제 객체를 의미
4. 주로 비즈니스 로직이나 동작을 포함

---

### 엔티티 매니저와 엔티티 매니저 팩토리란?

`엔티티 매니저( Entity Manager )`

1. 영속성 컨텍스트(Persistence Context)를 관리
2. 엔티티의 상태를 관리
3. 데이터베이스와의 상호 작용을 담당하는 주요 객체

`엔티티 매니저 팩토리( Entity Manager Factory )`

1. 엔티티 매니저를 생성하는 역할
2. 데이터베이스와의 연결을 설정
3. 애플리케이션의 시작 시점에 한 번만 생성되고, 애플리케이션 전체에서 공유

---

### 엔티티 생명주기는?

`비영속( Transient )`

- 엔티티가 생성되었지만 영속성 컨텍스트에 관리되지 않은 상태

`영속( managed )`

- 엔티티가 영속성 컨텍스트에 관리되고 있는 상태

`준영속( detached )`

- 엔티티가 영속성 컨텍스트와의 관계가 끊긴 상태

`삭제( removed )`

- 엔티티가 영속성 컨텍스트에서 삭제된 상태

---

### 영속성 전이란?

- JPA에서 엔티티 간의 관계가 설정된 경우, 부모 엔티티의 상태 변화가 자식 엔티티에 영향을 미치는 것
- @OneToMany, @OneToOne, @ManyToMany 등과 같은 관계 매핑 어노테이션과 함께 사용
- 데이터베이스 간의 일관성을 유지하고 관리하기 편리한 코드를 작성가능
- ALL, PERSIST, REMOVE 등의 옵션이 있다.

---

### 데이터베이스 즉시 쓰기, 쓰기지연, 변경감지 차이

`즉시 쓰기(Immediate Write)`

- 영속성 컨텍스트에 새로운 엔티티가 영속화될 때마다 바로 데이터베이스에 쓰기 작업을 수행
- 트랜잭션이 커밋되기 전에 모든 엔티티의 상태가 데이터베이스에 동기화

`쓰기 지연(Write Behind)`

- 영속성 컨텍스트에 새로운 엔티티가 저장되어도, 실제 데이터베이스에는 트랜잭션이 커밋되는 시점에 변경 내역이 반영
- 여러 엔티티의 상태를 한 번에 데이터베이스에 반영하여 성능을 향상

`변경 감지(Dirty Checking)`

- 영속성 컨텍스트가 엔티티의 상태를 주기적으로 모니터링하고, 변경된 엔티티를 감지하여 데이터베이스에 자동으로 반영
- 트랜잭션을 커밋할 때 변경된 엔티티만을 식별하여 데이터베이스에 쓰기 작업을 수행

---

### 엔티티 기본키 전략은?

`직접 할당 전략( Assigned Strategy )`

- 엔티티의 기본키 값을 직접 할당하는 전략
- @Id 형태

`자동 생성 전략( Auto Generation Strategy )`

- 데이터베이스가 자동으로 기본키 값을 생성하는 전략
- @GeneratedValue(strategy = GenerationType.전략명) 형태

`전략명`

1. Identity

- 기본 키 생성을 데이터베이스에 위임
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용

2. Sequence

- DB의 시퀀스를 활용하여 Id값을 증가
- 주로 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용

3. Table

- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
- 모든 데이터베이스에 적용 가능하나, 성능적인 손해가 있어서 잘 쓰지 않는다.

4. AUTO

- DB에 따라 자동으로 3가지 전략 중 하나를 선택
- 특정 데이터베이스 벤더에 종속되지 않고 여러 데이터베이스에서 애플리케이션을 실행할 때 유용

---

### Auditing 공통 속성 공통화란?

- 감사(Auditing) 속성은 데이터 변경을 추적하고 기록하는데 사용
- 대표적인 속성으로는 생성자, 생성일, 수정자, 수정일 등이 있다.
- 공통 속성들을 공통화하여 코드 중복을 줄이고 유지보수성을 향상시키기 위해 사용

---

### VO, BO, DAO, DTO란?

- 데이터와 비즈니스 로직을 표현하는 데 사용되는 여러 개념

`VO (Value Object)`

- 값 객체, 데이터의 조합으로 이루어진 불변한 객체
- 주로 데이터를 그룹화하고 전달하는 데 사용

`BO (Business Object)`

- 비즈니스 객체, 비즈니스 로직을 포함하는 객체
- 주로 시스템의 핵심 비즈니스 규칙을 캡슐화하고, 이를 통해 데이터와 상호 작용

`DAO (Data Access Object)`

- 데이터 액세스 객체, 데이터베이스와의 상호 작용을 처리하는 객체
- 주로 데이터베이스에 대한 CRUD 작업을 수행하고, 데이터베이스 연산을 캡슐화

`DTO (Data Transfer Object)`

- 데이터 전송 객체, 클라이언트와 서버 간에 데이터를 전송하고 전달하는 객체
- 주로 네트워크 또는 서비스 간의 데이터 교환을 위해 사용

---

### 롬북( Lombok ) 라이브러리란?

- 자바 언어를 위한 라이브러리로, 코드를 간결하게 작성할 수 있도록 도와주는 도구
- 주로 자주 사용되는 Getter, Setter, Constructor 등의 메서드를 자동으로 생성해주는 기능을 제공
- 주석 기반의 프로세서를 사용하여 컴파일 시점에 코드를 생성

---

### Modelmapper란?

- 자바 객체 간의 매핑을 간편하게 처리하기 위한 라이브러리
- 같은 이름을 가진 속성들을 자동으로 매핑
- 일반적으로 DTO와 Entity 간의 매핑에서 사용

---

### 어노테이션/애노테이션( @ )이란?

- 자바 프로그래밍 언어의 특별한 형태의 메타데이터
- 코드에 부가적인 정보를 제공하는 역할
- 주로 컴파일러, 개발 도구, 프레임워크 등에 의해 사용되어 특정한 동작을 지정하거나 설정할 때 활용
- 보다 간결하고 유연한 코드를 작성할 수 있으며, 코드의 가독성과 유지보수성을 향상

---

### @Controller 와 @RestController의 차이는?

- 웹 요청을 처리하는 데 사용되는 어노테이션

`@Controller`

1. 전통적인 스프링 MVC 컨트롤러를 정의할 때 사용
2. 주로 View를 반환하는 작업을 수행

`@RestController`

1.  RESTful 웹 서비스를 제공하는 컨트롤러를 정의할 때 사용
2.  주로 JSON 또는 XML 형식의 데이터를 반환하는 작업을 수행

---

### @RequestBody와 @RequestParam의 차이는?

- 웹 요청을 처리하는 데 사용되는 어노테이션

`@RequestBody`

1. HTTP 요청의 본문(body)에 포함된 데이터를 메서드의 파라미터로 매핑할 때 사용
2. 주로 POST나 PUT 요청과 함께 JSON 또는 XML 형식의 데이터를 전송할 때 사용

`@RequestParam`

1. HTTP 요청의 쿼리 파라미터(query parameter)를 메서드의 파라미터로 매핑할 때 사용
2. 주로 GET 요청에서 ?key=value 형식으로 전달되는 쿼리 파라미터를 처리할 때 사용

---

### Querydsl이란?

- 자바로 작성된 유연하고 형식 안정적인 데이터베이스 쿼리를 생성하기 위한 오픈 소스 프레임워크

`장점`

1. 컴파일 시점에 오류를 발견 할 수 있다.
2. 객체 지향적인 쿼리 작성이 가능
3. 쿼리를 자바 코드 내에 포함시킬 수 있다.
4. 동적으로 쿼리 생성

`단점`

1. 엔터티 또는 데이터 모델이 변경될 때마다 Q클래스를 다시 생성해야 한다.

---

### 동적 쿼리란?

- 실행 시점에 생성되는 SQL 쿼리
- 정적 쿼리와는 달리 동적 쿼리는 실행 시에 동적으로 생성되므로 실행 전에 정확한 쿼리 문자열이 결정되지 않는다.
- 사용자가 입력한 값에 따라 쿼리의 일부 또는 조건을 동적으로 추가 또는 변경해야 할 때 사용
- SQL 삽입 공격 등의 보안 문제가 발생할 수 있다.

---

### constant(상수)란?

- 프로그램 내에서 변하지 않는 값을 의미
- 한 번 정의되면 그 값이 프로그램 실행 동안 변경되지 않는다.
- 프로젝트의 여러 부분에서 공통적으로 사용되는 값
- 상수는 보통 대문자로 작성하며, 여러 단어가 결합될 때는 밑줄(\_)로 구분

---

### Pageable이란?

- 스프링 데이터에서 사용되는 인터페이스로, 데이터를 페이징하여 반환하는데 사용
- PageRequest 클래스를 사용하여 Pageable 객체를 생성

---

### @Transactional에 readOnly 속성을 사용하는 이유는?

- 읽기 전용 모드, 수정하는 서비스에 적용하면 안된다.
- 해당 메서드가 데이터를 읽기만 한다는 것을 DB에 알려줌으로써 쿼리 및 캐싱을 최적화
- 실수로 데이터를 수정해서 일관성을 위반하는 것을 방지
- DB에서 데이터를 읽기만 한다는 것을 명확하게 확인가능

---

### Filter와 Interceptor차이

- 모두 웹 애플리케이션에서 HTTP 요청을 가로채고 처리하는 데 사용

`Filter`

1. 서블릿 컨테이너에서 모든 HTTP 요청에 대해 적용되는 전역적인 작업을 처리하는 데 사용
2. 주로 웹 애플리케이션의 모든 URL에 대해 적용
3. 로깅, 보안, 인코딩 변환 등과 같은 전역적인 작업을 처리하는 데 사용

`Interceptor`

1. Spring MVC에서 컨트롤러에만 적용되는 특정한 작업을 처리하는 데 사용
2. 요청 전, 후, 뷰 렌더링 후 등의 시점에 작업을 수행
3. 로깅, 인증, 권한 확인 등과 같은 컨트롤러 수준의 작업을 처리하는 데 사용

---

### 어노테이션/애노테이션 종류 및 설명

`엔티티( Entity )`

1. @Entity - 클래스를 JPA 엔티티로 지정
2. @Table - 데이터베이스 테이블의 이름을 지정
3. @Column -데이터베이스 컬럼과 매핑
4. @JoinColumn - 조인 컬럼을 지정하여 관계를 매핑
5. @Embedded - 엔티티 클래스 내부에 다른 엔티티를 포함시킬 때 사용

`DTO( Data Transfer Object )`

1. @Data - getter, setter, equals, hashCode, toString 등의 메서드를 자동으로 생성
2. @NoArgsConstructor - 파라미터가 없는 기본 생성자를 자동으로 생성
3. @AllArgsConstructor - 모든 필드를 인자로 받는 생성자를 자동으로 생성
4. @Builder - 빌더 패턴을 사용하여 객체를 생성
5. @Valid - DTO의 유효성 검사를 수행
6. @Size - 문자열이나 컬렉션의 크기를 제한
7. @NotBlank - 문자열이 null이 아니고 공백이 아닌지 검사
8. @NotNull - 값이 null이 아닌지 검사
9. @JsonIgnore - 특정 필드를 JSON 직렬화/역직렬화에서 제외
10. @JsonFormat - 날짜 형식을 지정하여 JSON 직렬화/역직렬화할 때 사용

`컨트롤러( Controller )`

1. @RequestMapping - 요청 URL과 컨트롤러 메서드를 매핑할 때 사용
2. @GetMapping - GET요청에 대한 처리
3. @PostMapping - POST요청에 대한 처리
4. @PutMapping - PUT요청에 대한 처리
5. @DeleteMapping - DELETE요청에 대한 처리
6. @PathVariable - 요청 URL에서 경로 변수를 추출하여 메서드의 파라미터로 전달할 때 사용
7. @ResponseBody - 메서드의 반환 값을 HTTP 응답 본문으로 사용할 때 사용
8. @ModelAttribute - 요청 파라미터를 자동으로 모델 객체로 변환하여 컨트롤러 메서드의 파라미터로 전달할 때 사용
9. @SessionAttributes - 세션에 속성을 저장하거나 세션 속성을 컨트롤러에 전달할 때 사용

`서비스( Service )`

1. @Service - 해당 클래스가 비즈니스 로직을 담당하는 서비스 클래스임을 나타낸다.
2. @Transactional - 트랜잭션 처리를 위해 사용
3. @Autowired - 의존성 주입을 위해 사용

`Repository`

1. @Repository - 해당 인터페이스를 리포지토리로 지정
2. @QuerydslPredicate - Querydsl을 사용하여 동적 쿼리를 생성할 때 사용

`기타`

1. @RequiredArgsConstructor - 해당클래스의 final 필드나 @NonNull이 붙은 필드를 파라미터로 받는 생성자를 자동으로 생성

---
