---
title: "네트워크 면접 개념정리"
author:
  name: 김병우
  link: https://github.com/Woob29
date: 2024-02-20 14:20:00 +0900
categories: [네트워크, 개념정리]
---

### 네트워크란?

- 컴퓨터나 다른 기술적 장치들이 정보를 주고받을 수 있도록 연결된 구조

---

### 서브넷 마스크( subnet mask ) 란?

- ip 주소를 서브넷에 나누는 데 사용되는 32비트 숫자
- ip 주소를 네트워크 id영역과 호스트 ip영역으로 구분하는 역활
- 네트워크를 식별하고 서브넷을 구분하는 데 중요한 역할

---

### 세브넷팅이란?

- 하나의 대형 네트워크를 작은 네트워크로 분할하는 프로세스
- 네트워크 트래픽을 최적화하고 보안을 강화
- 더 많은 장치를 지원하기 위해 서브넷에 할당되는 IP 주소의 범위를 조정

  |서브넷마스크|네트워크|각 네트워크별 ip주소 수량|
  |:---:|:---:|:---:|
  |255.255.255.0 (/24)|1개|256개|
  |255.255.255.128 (/25)|2개|128개|
  |255.255.255.192 (/26)|4개|64개|
  |255.255.255.224 (/27)|8개|32개|
  |255.255.255.240 (/28)|16개|16개|
  |255.255.255.248 (/29)|32개|8개|
  |255.255.255.252 (/30)|64개|4개|

---

### 패킷이란?

- 컴퓨터 네트워크에서 데이터를 전송하는 데 사용되는 작은 데이터 조각
- 네트워크를 통해 전송되는 모든 데이터는 패킷의 형태로 나누어져 전송

`헤더( header )`
  - 송신자 및 수신자의 주소, 패킷의 크기, 프로토콜 및 기타 관련 정보를 포함

`데이터( Data )`
  - 실제 전송되는 데이터가 포함

`트레일러( Trailer )`
  - 패킷의 무결성을 확인하기 위해 사용
  - 일부 프로토콜에서는 트레일러가 생략될 수 있다.

---

### 프로토콜이란?

- 컴퓨터와 네트워크 장치 사이에 통신하기 위한 규칙과 규정의 집합
- 데이터의 전송, 수신, 오류 검출 및 수정, 보안 등과 같은 다양한 통신 작업을 정의하고 관리
- 네트워크 통신, 인터넷 프로토콜(IP), 전자 메일(이메일) 프로토콜, 웹(HTTP) 프로토콜 등과 같은 다양한 응용 분야에서 사용

---

### OSI 7계층, TCP/IP 4계층이란?

- 네트워크 프로토콜을 디자인과 통신을 계층으로 나누어 설명하기 위해 개발한 모델
- OSI 모델을 기반으로 실제 사용될 수 있게 간결해진 모델이 TCP/IP 4계층 모델이다.

`OSI( Open Systems Interconnection ) 7계층`
  1. 물리 계층 - 물리적으로 데이터를 전송하고 물리적 연결을 관리
  2. 데이터링크 계층 - 인접한 노드 간의 신뢰성 있는 데이터 전송을 담당, 오류 검출 및 수정을 제공
  3. 네트워크 계층 - 서로 다른 네트워크 간의 패킷 전달 및 라우팅을 처리
  4. 전송 계층 - 끝 간 통신을 관리하고 데이터의 신뢰성과 무결성을 보장
  5. 세션 계층 - 데이터 교환의 시작과 종료를 관리하며 세션 복구를 제공
  6. 표현 계층 - 데이터의 표현 방식을 정의하고 데이터 변환, 암호화, 복호화 등을 수행
  7. 응용 계층 - 사용자에게 인터페이스를 제공하며 프로토콜 및 서비스에 대한 접근을 제어

  |계층|이름|설명|
  |:---:|:---:|:---:|
  |7 계층|응용 계층|
  |6 계층|표현 계층|
  |5 계층|세션 계층|
  |4 계층|전송 계층|
  |3 계층|네트워크 계층|
  |2 계층|데이터링크 계층|
  |1 계층|물리 계층|

`TCP/IP 4계층`
  1. 네트워크 액세스 계층 - OSI 1,2 계층에 속함
  2. 인터넷 계층 - OSI 3 계층에 속함
  3. 전송 계층 - OSI 4 계층에 속함
  4. 응용 계층 - OSI 5,6,7 계층에 속함

  |계층|이름|
  |:---:|:---:|
  |4 계층|응용 계층|
  |3 계층|전송 계층|
  |2 계층|인터넷 계층|
  |1 계층|네트워크 액세스 계층|

---

### HTTP와 HTTPS의 공통점과 차이점은?

- 인터넷에서 웹 페이지를 전송하는 데 사용되는 프로토콜
- 클라이언트와 서버 간의 데이터 전송을 가능하게 한다.
- 클라이언트가 서버에 요청(Request)을 보내고, 서버가 요청에 대한 응답(Response)을 보내는 형태로 동작

`HTTP ( Hypertext Transfer Protocol )`
  1. 데이터를 암호화하지 않고 평문으로 전송, 따라서 중간자 공격과 같은 보안 위협에 취약
  2. TCP 80번 포트를 사용하여 통신
  3. URL이 "http://"로 시작
  4. 상호 인증을 제공하지 않는다.

`HTTPS ( Hypertext Transfer Protocol Secure )`
   1. HTTP 프로토콜의 보안 버전으로, 데이터의 암호화와 인증을 제공하여 보안을 강화
   2. SSL 또는 TLS 프로토콜을 사용하여 데이터를 암호화하여 전송, 이를 통해 데이터의 기밀성과 무결성을 보호하고 보안을 강화
   3. TCP 443번 포트를 사용하여 통신
   4. URL이 "https://"로 시작
   5. 서버 및 클라이언트 간의 상호 인증을 제공하여 사용자가 신뢰할 수 있는 서버와 통신하는지 확인

---

### TCP와 UDP의 차이

- 네트워크 통신에서 사용되는 두 가지 주요 프로토콜

`TCP(Transmission Control Protocol)`
  1. 연결 지향적이며, 통신을 시작하기 전에 세션을 설정하고 종료하기 전에 세션을 해제
  2. 데이터 전송의 신뢰성과 순서 보장을 보장
  3. 데이터가 손실되거나 손상된 경우 자동으로 재전송을 수행하고, 데이터의 순서를 보장
  4. 헤더에는 연결 설정, 순서 번호, 확인 응답 번호 등의 추가 정보가 포함
  5. 신뢰성 있는 데이터 전송이 필요한 응용 프로그램에 적합
  6. 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점

`UDP(User Datagram Protocol)`
  1. 비연결 지향적이며, 통신을 시작하기 전에 세션을 설정하지 않고 데이터를 전송
  2. 빠른 전송을 제공하지만 데이터의 손실이나 순서가 보장되지 않는다.
  3. 데이터가 손실되거나 손상되더라도 재전송이나 오류 복구를 수행하지 않는다.
  4. 목적지 및 출발지 포트 번호, 길이 등의 기본 정보만 포함
  5. 실시간 데이터 스트리밍, DNS(Domain Name System), 음성 통화, 온라인 게임 등과 같이 신속한 데이터 전송이 중요한 응용 프로그램에 적합
  6. 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점

---

### TCP 통신은 종료시에도 3 way-handshaking을 사용?

- TCP는 3 way-handshaking 과정을 통해 연결을 설정하고, 4 way-handshaking 과정을 통해 연결을 해제

---

### 3 way-handshake와 4 way-handshake란?

`3-way handshake`
  1. TCP의 연결 설정을 위해 사용
  2. 클라이언트가 서버와 안전하게 연결을 설정하기 위해 사용
  3. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인

`4-way handshake`
  1. TCP의 연결 종료를 위해 사용
  2. 클라이언트나 서버 중 하나가 연결을 종료하고자 할 때 사용
  3. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 종료

---

### 쿠키와 세션의 차이점은?

- 웹 개발에서 상태를 유지하고 사용자를 식별하는 데 사용되는 두 가지 메커니즘

`쿠키( Cookie )`
  1. 클라이언트 측에 저장
  2. 웹 브라우저에 텍스트 파일 형태로 저장
  3. 만료 날짜를 설정가능
  4. 클라이언트에 저장되므로 사용자가 쿠키를 조작하거나 삭제할 수 있으므로 보안에 취약

`세션( Session )`
  1. 서버 측에 저장
  2. 세션 데이터는 서버의 메모리 또는 데이터베이스에 저장
  3. 사용자가 웹 브라우저를 닫거나 로그아웃할 때까지 유지, 브라우저를 닫으면 세션은 종료되고 데이터는 삭제
  4. 서버 측에 저장되므로 클라이언트에 저장된 쿠키보다 보안이 더 강력

---

### 로드 밸런싱이란?

- 네트워크나 애플리케이션 서버에 걸쳐 있는 작업 부하를 균형 있게 분산하는 기술
- 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적

---

### 로드 밸런싱기법에는?

`라운드로빈 방식( Round Robin Method )`
  1. 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
  2. 모든 서버가 동일한 부하를 처리하므로 간단하고 공평한 방식

`가중 라운드로빈 방식( Weighted Round Robin Method )`
  1. 각 서버에 가중치를 할당하여 부하를 분산하는 방식
  2. 서버의 성능이나 용량에 따라 가중치를 조절하여 특정 서버에 더 많은 요청을 보내도록 할 수 있다.

`IP 해시 방식( IP Hash Method )`
  1. 클라이언트의 IP 주소를 해시하여 특정 서버에 요청을 전달하는 방식
  2. 동일한 클라이언트가 항상 동일한 서버로 연결되도록 보장

`최소 연결 방식( Least Connection Method )`
  1. 현재 연결된 클라이언트 수가 가장 적은 서버에 요청을 전달하는 방식
  2. 서버의 현재 부하 상태를 고려하여 요청을 분배하기 때문에 성능을 최적화

`최소 응답 시간 방식( Least Response Time Method )`
  1. 서버의 응답 시간이 가장 짧은 서버에 요청을 전달하는 방식
  2. 실제 응답 시간을 측정하여 최적의 서버를 선택

`상태 기반 로드 밸런싱 방식( Stateful Load Balancing Method )`
  1. 클라이언트의 세션 정보나 상태를 기반으로 서버를 선택하는 방식
  2. 사용자 경험을 개선하고 세션 일관성을 유지하기 위해 사용

---

### 프록시 서버란?

- 클라이언트와 원격 서버 간의 중계 역할을 수행하는 중간 서버
- 클라이언트의 요청을 받아 해당 요청을 다른 서버로 전달하고, 서버로부터 받은 응답을 클라이언트에게 반환
- 네트워크 보안, 성능 최적화, 콘텐츠 필터링 등 다양한 용도로 사용

---

### HTTP Method와 각각이 사용되는 경우

-  클라이언트가 서버에게 요청을 보낼 때 사용되는 명령

`GET`
   1. 리소스를 요청하여 가져올 때 사용
   2. 요청 본문에 데이터를 포함할 수 없다.
   3. 데이터는 URL의 쿼리 문자열(query string)에 포함되어 전송
   4. 캐시 가능하며, 브라우저에서 링크를 클릭하거나 주소 표시줄에 URL을 입력할 때 사용
   5. 데이터는 URL의 일부로 노출되며, 길이에 제한

`POST`
   1. 리소스를 생성하거나 업데이트할 때 사용
   2. 요청 본문에 데이터를 포함하여 서버로 전송
   3. URL에 노출되지 않으며, 데이터 길이에 제한이 없다.
   4. 캐시되지 않으며, 주로 사용자의 상호 작용으로 인한 변경을 처리할 때 사용

`PUT`
   1. 리소스를 생성하거나 업데이트할 때 사용
   2. 클라이언트가 리소스의 특정 위치에 리소스를 업로드하거나 교체할 때 사용
   3. 요청 본문에 데이터를 포함하여 서버로 전송

`PATCH`
   1. 리소스의 일부( 특정 부분 )를 수정할 때 사용
   2. 요청 본문에 데이터를 포함하여 서버로 전송

`DELETE`
   1. 지정된 리소스를 삭제할 때 사용
   2. 일반적으로 요청 본문에 데이터를 포함하지 않는다.

---

### API( Application Programming Interface )란?

- 운영체제와 프로그래밍 언어가 제공하는 라이브러리를 사용하여 개발자가 쉽게 개발할 수 있도록 하는 인터페이스
- 다른 애플리케이션이나 플랫폼에서 제공하는 데이터와 서비스에 접근하고 조작할 수 있는 방법을 제공
- 주로 웹 서비스, 라이브러리, 프레임워크 등의 형태로 제공

---

### REST, REST API( RESTful API ) 란?

- 웹 서비스를 설계하고 구현하는 데 사용

`REST ( Representational State Transfer )`
  1. 프로토콜이나 표준이 아닌 아키텍처적인 제약 조건을 제공
  2. 자원을 이름으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미
  3. 자원(resource)의 표현(representation)에 의한 상태 전달

`REST API ( RESTful API )`
  1. REST 아키텍처를 기반으로 설계된 API를 의미
  2. REST의 원칙을 따르며, 클라이언트와 서버 간의 통신을 위해 표준 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용

---

### JWT( JSON Web Token ) 토큰이란?

- 웹 애플리케이션에서 사용자 인증 및 권한 부여를 위한 토큰 기반의 인증 방식 중 하나
- 정보를 안전하게 전달하기 위한 표준 방법 중 하나이며, 웹 토큰(Web Token)의 한 유형
- 헤더, 페이로드, 서명 세가지 구성 요소로 이루어져 있다.

`헤더( Header )`
  - 토큰의 유형과 사용된 해시 알고리즘 등의 메타데이터를 포함

`페이로드( Payload )`
  - 사용자에 대한 정보와 추가적인 메타데이터를 포함

`서명( Signature )`
  - 토큰의 유효성을 검증하기 위한 서명

---

### 대칭키, 비대칭키 암호화 방식이란

`대칭키( Symmetric Key ) 암호화`
  1. 동일한 키를 암호화와 복호화에 모두 사용하는 방식, 데이터의 보안을 위해 사용
  2. 데이터를 암호화하는 데 사용된 키와 동일한 키를 사용하여 데이터를 복호화
  3. 구현이 간단하고 빠르고 효율적인 장점
  4. 키 배송 및 관리에 대한 보안 문제의 단점
  5. 대칭키 알고리즘에는 DES(Data Encryption Standard), AES(Advanced Encryption Standard), Blowfish 등이 있다.

`비대칭키( Asymmetric Key ) 암호화`
  1. 공개 키(Public Key)와 개인 키(Private Key) 두 개의 서로 다른 키를 사용하는 방식,  키 교환 및 디지털 서명에 사용
  2. 데이터를 암호화하는 데 사용된 공개 키는 데이터를 복호화하는 데 사용된 개인 키와는 다르다.
  3. 두 당사자 간에 안전하게 통신하고 안전한 키 배송( 암호화 키를 다른 당사자에게 전달하는 과정 )이 필요하지 않는 장점
  4. 키 관리 및 계산 복잡하고 대칭키 암호화보다 느린 단점
  5. 비대칭키 알고리즘에는 RSA(Rivest-Shamir-Adleman), ECC(Elliptic Curve Cryptography), DSA(Digital Signature Algorithm) 등이 있다.

---

### 응답 상태 코드란

- 클라이언트가 서버에 요청을 보내고 서버가 해당 요청에 대한 응답을 반환할 때 전송되는 숫자로 이루어진 코드
- 대부분의 HTTP 통신에서 사용되며, 클라이언트는 이 코드를 통해 요청의 결과를 파악하고 적절한 조치를 취할 수 있다.

`1xx ( Informational )`
  - 요청을 처리하는 데 추가 정보가 필요함을 나타낸다.

`2xx ( Success )`
  - 요청이 성공적으로 처리되었음을 나타낸다.

`3xx ( Redirection )`
  - 요청을 완료하기 위해 추가 조치가 필요함을 나타낸다.

`4xx ( Client Error )`
  - 클라이언트 측에서 발생한 오류를 나타낸다.

`5xx ( Server Error )`
  - 서버 측에서 발생한 오류를 나타낸다.

---

### Connection Timeout과 Read Timeout의 차이

- 네트워크 통신에서 발생할 수 있는 두 가지 다른 종류의 타임아웃

`Connection Timeout ( 연결 시간 초과 )`
  1. 클라이언트가 서버에 연결을 시도할 때 발생
  2. 클라이언트가 서버에 연결 요청을 보내고, 서버가 이를 수락하거나 거부할 때까지 대기하는 시간을 의미
  3. 주로 서버가 응답하지 않는 상태 또는 네트워크 문제로 인해 발생
  4. 클라이언트가 서버와의 연결을 설정하는 데 걸리는 시간을 제한

`Read Timeout ( 읽기 시간 초과 )`
  1. 클라이언트가 서버로부터 데이터를 읽는 동안 발생
  2. 클라이언트가 서버에 요청을 보내고 서버가 응답을 반환하는 동안 대기하는 시간을 의미
  3. 주로 서버가 데이터를 제때 보내지 않거나 네트워크 지연으로 인해 발생
  4.  클라이언트가 서버로부터 데이터를 읽는 데 걸리는 시간을 제한

---

### KeepAlive란?

- 네트워크 통신에서 사용되는 기능 중 하나
- 일반적으로 HTTP 프로토콜에서 사용되며, 클라이언트와 서버 간의 연결을 오랫동안 유지하지 않고 효율적으로 관리하기 위해 사용

---

### 공인(public) IP와 사설(private) IP의 차이

- 네트워크에서 사용되는 두 가지 주요한 종류의 IP 주소
- 네트워크 관리 및 보안 목적으로 구분

`공인( IPv4와 IPv6 ) IP 주소`
  1. 인터넷에 공개되어 있으며, 인터넷 상에서 다른 장치들과 통신하는 데 사용
  2. 전 세계적으로 고유한 주소로, 중복되지 않는 주소
  3. 인터넷 서비스 제공업체(ISP)에 의해 할당

`사설( IPv4와 IPv6 ) IP 주소`
  1. 비공개적인 주소 범위로, 내부 네트워크에서만 사용
  2. 특정 IP 주소 범위에 속하며, 여러 조직이나 개인이 동일한 IP 주소를 사용할 수 있다.
  3. 인터넷에 직접적으로 노출되지 않는다.
  4. 주로 NAT(Network Address Translation)을 사용하여 인터넷에 접속할 때 공인 IP 주소와 매핑되어 사용

---

### CORS( Cross-Origin Resource Sharing )란?

- 웹 애플리케이션에서 다른 출처의 리소스에 접근하는 것을 허용하는 메커니즘
- 보안 상의 이유로 브라우저가 동일 출처 정책에 따라 리소스 접근을 제한하는데, CORS는 이를 우회하여 다른 출처의 도메인에서 온 요청을 허용
- 이를 가능하게 하기 위해 HTTP 헤더를 사용하여 서버와 클라이언트 간의 통신을 제어

---

### 웹 페이지의 랜더링 과정

1. 브라우저의 캐시를 확인
   - 캐시에 저장된 ip주소가 없으면, UDP로 DNS서버에 해당 도메인 요청

2. 도메인을 찾은 후 브라우저에 전송
   - 브라우저는 TCP 연결 설정 후 GET요청

3. HTML 문서 다운로드
   - 클라이언트(웹 브라우저)가 웹 페이지의 URL을 요청하면 서버에서 해당 HTML 문서를 다운로드
   - 요청은 HTTP 요청을 통해 이루어진다.

4. HTML 파싱
   - 브라우저는 다운로드한 HTML 문서를 읽고 파싱하여 문서 객체 모델(DOM)을 생성
   - DOM은 HTML 문서의 구조를 나타내는 트리 구조

5. CSS 다운로드 및 파싱
   - HTML 파싱 중에 CSS 링크 태그를 만나면 브라우저는 해당 CSS 파일을 다운로드하고 파싱

6. 레이아웃 생성
   - DOM과 CSSOM(CSS Object Model)을 결합하여 렌더링 트리(Render Tree)를 생성
   - 렌더링 트리는 브라우저에서 실제로 표시되는 요소만을 포함

7. 렌더링
   - 렌더링 트리를 기반으로 각 요소의 크기와 위치를 계산하여 화면에 렌더링
   - 브라우저의 렌더링 엔진에 의해 수행

8. 자바스크립트 다운로드 및 실행 (선택적)
   - HTML 파싱 중에 자바스크립트 스크립트를 만나면 브라우저는 해당 스크립트를 다운로드하고 실행
   - 자바스크립트는 DOM 요소를 동적으로 변경하거나 이벤트를 처리하는 등의 작업을 수행 가능(비동기)

9. 리플로우와 리페인트
   - 자바스크립트 실행으로 인해 레이아웃이 변경되면 발생하며, 브라우저가 변경된 요소를 다시 그리게 된다.
   - 리플로우(reflow)는 요소의 레이아웃이 변경되어 다시 계산되는 과정
   - 리페인트(repaint)는 변경된 요소의 스타일에 따라 화면에 다시 그려지는 과정

10. 페이지 완전 로드
    - 모든 자원이 다운로드 되고 실행된 후에 페이지의 로딩이 완료
    - 사용자가 페이지를 완전히 볼 수 있고, 모든 기능을 사용할 수 있을 때를 의미

---